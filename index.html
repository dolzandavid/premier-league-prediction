<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Premier League Predictor</title>
  <script type="module" src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script type="module" src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
  <script type="module" src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
 <style>
  /* Force styles just for the Predictions stats button */
  #btnPredStats {
    background-color: #4f46e5 !important; /* indigo-600 */
    color: #ffffff !important;
    padding: 0.25rem 0.75rem !important;  /* py-1 px-3 */
    border-radius: 0.25rem !important;    /* rounded */
    display: inline-block !important;
    opacity: 1 !important;
    pointer-events: auto !important;
    filter: none !important;
  }
  #btnPredStats:hover {
    background-color: #4338ca !important; /* indigo-700 */
  }
</style>
  <style>
    input[type="number"]::-webkit-inner-spin-button,
    input[type="number"]::-webkit-outer-spin-button {
      opacity: 1;
    }
  </style>
</head>
<body class="bg-gray-100 text-gray-800">

<!-- Loading Overlay -->
<div id="loadingOverlay" class="fixed inset-0 bg-white bg-opacity-80 flex items-center justify-center z-50 hidden">
  <div class="bg-white border border-gray-300 rounded px-6 py-4 shadow text-lg font-semibold">
    Loading fixtures, please wait...
  </div>
</div>

<!-- History Modal -->
<div id="historyModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
  <div class="bg-white p-6 rounded shadow-lg max-w-lg w-full">
    <h2 class="text-lg font-semibold mb-4">Fixture Data</h2>
    <div id="historyContent" class="text-sm max-h-80 overflow-y-auto whitespace-pre-wrap"></div>
    <button id="closeHistoryBtn" class="mt-4 bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded">Close</button>
  </div>
</div>

  <div class="max-w-5xl mx-auto p-4">
    <h1 class="text-2xl font-bold mb-4 text-center">Premier League Prediction Game</h1>

    <!-- LOGIN + CHANGE PASSWORD SECTION -->
    <div id="loginSection" class="mb-6 space-y-4">
      <div>
        <select id="username" class="border p-2 mr-2">
          <option value="" disabled selected>Select user</option>
          <option value="david">David</option>
          <option value="katja">Katja</option>
          <option value="mark">Mark</option>
          <option value="jus">Jus</option>
        </select>
        <input id="password" type="password" class="border p-2 mr-2" placeholder="Password" />
        <button id="loginBtn" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded">Login</button>
      </div>
      <div class="text-sm">
        <button id="showChangePwBtn" class="text-blue-500 hover:underline">Change password</button>
      </div>
      <div id="changePwSection" class="hidden space-y-2">
        <h3 class="font-semibold">Change Password</h3>
        <input id="oldPw" type="password" class="border p-2 w-full" placeholder="Old Password" />
        <input id="newPw" type="password" class="border p-2 w-full" placeholder="New Password" />
        <button id="changePwBtn" class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded">Change Password</button>
      </div>
    </div>
    <!-- APP UI -->
    <div id="app" style="display:none;">
      <div class="flex justify-between items-center mb-4">
        <span id="welcomeUser" class="font-semibold"></span>
        <button id="logoutBtn" class="bg-gray-500 hover:bg-gray-600 text-white px-3 py-1 rounded">Logout</button>
      </div>

      <!-- Gameweek Selector -->
      <div class="mb-4 flex items-center">
        <label for="gameweekSelect" class="mr-2 font-medium">Gameweek:</label>
        <select id="gameweekSelect" class="border p-2"></select>
        <span id="gameweekDeadline" class="ml-4 text-sm text-gray-600"></span>
      </div>
      <!-- Stats buttons (visible to all logged-in users) -->
<div id="statsButtons" class="mb-4 flex gap-2" style="display:none;">
  <button id="btnLeagueTable" class="bg-indigo-600 hover:bg-indigo-700 text-white px-3 py-1 rounded text-sm">League Table</button>
  <button id="btnFormGuide"  class="bg-indigo-700 hover:bg-indigo-800 text-white px-3 py-1 rounded text-sm">Form Guide</button>
  <button id="btnPredStats" class="bg-indigo-600 hover:bg-indigo-700 text-white px-3 py-1 rounded text-sm">Predictions stats</button>
</div>

<!-- Stats Modal -->
<div id="statsModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
  <div class="bg-white p-6 rounded shadow-lg max-w-3xl w-full">
    <h2 id="statsModalTitle" class="text-lg font-semibold mb-4"></h2>
    <div id="statsModalContent" class="text-sm max-h-96 overflow-y-auto"></div>
    <button id="closeStatsBtn" class="mt-4 bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded">Close</button>
  </div>
</div>

 <div id="fixtureEditor" class="mb-6 hidden">
  <h2 class="text-lg font-semibold mb-2">Edit Fixtures</h2>

  <!-- Add Fixture -->
  <div class="grid grid-cols-1 gap-2 sm:grid-cols-3 sm:gap-3">
    <input id="newHomeTeam"
           class="w-full min-w-0 border rounded px-2 py-2 text-sm"
           placeholder="Home Team" />
    <input id="newAwayTeam"
           class="w-full min-w-0 border rounded px-2 py-2 text-sm"
           placeholder="Away Team" />
    <button id="addFixtureBtn"
            class="w-full sm:w-auto px-3 py-2 rounded bg-green-500 hover:bg-green-600 text-white text-sm">
      Add Fixture
    </button>
  </div>

  <!-- Deadline -->
  <div class="mt-3 grid grid-cols-1 gap-2 sm:grid-cols-3 sm:gap-3">
    <label for="deadlineInput" class="text-sm text-gray-700 self-center">Deadline:</label>
    <input type="datetime-local" id="deadlineInput"
           class="w-full min-w-0 border rounded px-2 py-2 text-sm" />
    <button id="setDeadlineBtn"
            class="w-full sm:w-auto px-3 py-2 rounded bg-blue-500 hover:bg-blue-600 text-white text-sm">
      Set Deadline
    </button>
  </div>
</div>


      <!-- Fixtures -->
      <div id="fixturesContainer" class="mb-8"></div>

      <!-- Leaderboards -->
      <div class="mb-6">
        <h2 class="text-lg font-semibold mb-2">Overall Leaderboard</h2>
        <div id="leaderboardOverallContainer">
<div id="leaderboardOverallLoading" class="flex justify-center my-4">
  <div class="animate-spin rounded-full h-6 w-6 border-t-2 border-b-2 border-gray-600"></div>
  <span class="ml-2 text-gray-600 text-sm self-center">Loading leaderboard...</span>
</div>
  <div id="leaderboardOverall" class="overflow-x-auto hidden"></div>
</div>

        <h2 class="text-lg font-semibold mt-6 mb-2">Weekly Leaderboard</h2>
        <div id="leaderboardWeekly" class="overflow-x-auto"></div>
      </div>

<!-- Save Season Stats (David only) -->
<div id="saveSeasonStatsWrap" class="mb-6 hidden">
  <button id="saveSeasonStatsBtn" class="bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded">
    Compute & Save Season Stats (to current GW)
  </button>
  <span id="saveSeasonStatsStatus" class="ml-3 text-sm text-gray-600"></span>
</div>
      
      <!-- Password Reset (David) -->
      <div id="passwordResetSection" class="hidden mb-8">
        <h2 class="text-lg font-semibold mb-2">Reset Player Password</h2>
        <select id="resetUserSelect" class="border p-2 mr-2"></select>
        <input id="newPasswordInput" class="border p-2 mr-2" placeholder="New Password" />
        <button id="resetPasswordBtn" class="bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded">Reset Password</button>
      </div>
    </div>
  </div>
  <script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
import { getFirestore, doc, setDoc, getDoc, collection, getDocs, deleteDoc, query, where, onSnapshot, updateDoc, deleteField } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyA2WG0LUwLCDqmylgezCZ0aH5Q8vTaXTKU",
  authDomain: "pl-predictor-13a6d.firebaseapp.com",
  projectId: "pl-predictor-13a6d",
  storageBucket: "pl-predictor-13a6d.appspot.com",
  messagingSenderId: "286908896536",
  appId: "1:286908896536:web:dabd76b4faaa72a98cfa6d"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

const users = { david:"david123", katja:"katja123", mark:"mark123", jus:"jus123" };

let currentUser="", currentGameweek="", deadlinesByWeek={};
let gameweekCache = {};
let currentFixtures = [], currentPredictions = {}, currentResults = {};

let cachedFixtures = [];
let cachedPredictions = {};
let cachedResults = {};

const loginBtn = document.getElementById("loginBtn");
const showChangePwBtn = document.getElementById("showChangePwBtn");
const changePwSection = document.getElementById("changePwSection");
const oldPw = document.getElementById("oldPw");
const newPw = document.getElementById("newPw");
const changePwBtn = document.getElementById("changePwBtn");
const logoutBtn = document.getElementById("logoutBtn");
const appDiv = document.getElementById("app");
const loginSection = document.getElementById("loginSection");
const welcomeUser = document.getElementById("welcomeUser");

// Toggle change-password form
showChangePwBtn.onclick = () => changePwSection.classList.toggle("hidden");

// Handle password change
changePwBtn.onclick = async () => {
  const user = document.getElementById("username").value;
  const oldPass = oldPw.value, newPass = newPw.value;
  if (!user || !oldPass || !newPass) return alert("Fill all fields");
  const snap = await getDoc(doc(db,"passwords",user));
  const saved = snap.exists() ? snap.data().password : users[user];
  if (oldPass !== saved) return alert("Old password is incorrect");
  await setDoc(doc(db,"passwords",user),{password:newPass});
  alert("Password changed!");
  oldPw.value=""; newPw.value="";
};

async function preloadAllGameweeks() {
  const fixtureDocs = await getDocs(collection(db, "fixtures"));
  const allFixtures = fixtureDocs.docs.map(d => ({ id: d.id, ...d.data() }));
  const weeks = [...new Set(allFixtures.map(f => f.gameweek))].filter(Boolean);

  const deadlinesSnap = await getDocs(collection(db, "deadlines"));
  const deadlineMap = {};
  deadlinesSnap.forEach(doc => {
    if (doc.exists()) deadlineMap[doc.id] = doc.data().deadline;
  });

  for (let week of weeks) {
    const fixtures = allFixtures.filter(f => f.gameweek === week);
    const predictionsSnap = await getDoc(doc(db, "predictions", week));
    const resultsSnap = await getDoc(doc(db, "results", week));
    const predictions = predictionsSnap.exists() ? predictionsSnap.data() : {};
    const results = resultsSnap.exists() ? resultsSnap.data() : {};
    const deadline = deadlineMap[week] || null;

    gameweekCache[week] = { fixtures, predictions, results, deadline };
  }
}

async function loadAllGameweekDataForLeaderboards() {
  const fixtureDocs = await getDocs(collection(db, "fixtures"));
  const allFixtures = fixtureDocs.docs.map(d => ({ id: d.id, ...d.data() }));
  const weeks = [...new Set(allFixtures.map(f => f.gameweek))].filter(Boolean);

  const deadlineSnap = await getDocs(collection(db, "deadlines"));
  deadlineSnap.forEach(doc => {
    if (doc.exists()) {
      deadlinesByWeek[doc.id] = new Date(doc.data().deadline);
    }
  });

  for (let week of weeks) {
    if (!gameweekCache[week]) gameweekCache[week] = {};
    const fixtures = allFixtures.filter(f => f.gameweek === week);

    const [predSnap, resSnap] = await Promise.all([
      getDoc(doc(db, "predictions", week)),
      getDoc(doc(db, "results", week))
    ]);

    gameweekCache[week].fixtures = fixtures;
    gameweekCache[week].predictions = predSnap.exists() ? predSnap.data() : {};
    gameweekCache[week].results = resSnap.exists() ? resSnap.data() : {};
  }

  // âœ… Only now is it safe to render
  renderLeaderboardsFromLocalCache();
sessionStorage.setItem("gameweekCache", JSON.stringify(gameweekCache));
sessionStorage.setItem("deadlinesByWeek", JSON.stringify(deadlinesByWeek));

}

async function determineClosestGameweek() {
  const fixtureDocs = await getDocs(collection(db, "fixtures"));
  const weeks = [...new Set(fixtureDocs.docs.map(d => d.data().gameweek))]
    .filter(Boolean).sort((a, b) => +a - +b);

  const deadlineDocs = await getDocs(collection(db, "deadlines"));
  deadlinesByWeek = {};
  deadlineDocs.forEach(docSnap => {
    const data = docSnap.data();
    if (data?.deadline) {
      deadlinesByWeek[docSnap.id] = new Date(data.deadline);
    }
  });

  const now = new Date();
  let closestWeek = null, minDiff = Infinity;
  for (let week of weeks) {
    const deadline = deadlinesByWeek[week];
    if (deadline) {
      const diff = Math.abs(deadline - now);
      if (diff < minDiff) {
        minDiff = diff;
        closestWeek = week;
      }
    }
  }

  currentGameweek = closestWeek || weeks[0] || "1";
}

async function populateGameweekDropdown() {
  const fixtureDocs = await getDocs(collection(db, "fixtures"));
  const weeks = [...new Set(fixtureDocs.docs.map(d => d.data().gameweek))]
    .filter(Boolean).sort((a, b) => +a - +b);

  const select = document.getElementById("gameweekSelect");
  select.innerHTML = weeks.map(w =>
    `<option value="${w}" ${w == currentGameweek ? "selected" : ""}>Gameweek ${w}</option>`
  ).join("");
}

function populateGameweekDropdownFromCache() {
  const weeks = Object.keys(gameweekCache).sort((a, b) => +a - +b);
  const select = document.getElementById("gameweekSelect");
  select.innerHTML = weeks.map(w =>
    `<option value="${w}" ${w == currentGameweek ? "selected" : ""}>Gameweek ${w}</option>`
  ).join("");
}


loginBtn.onclick = async () => {
  const user = document.getElementById("username").value;
  const pass = document.getElementById("password").value;
  const snap = await getDoc(doc(db, "passwords", user));
  const saved = snap.exists() ? snap.data().password : users[user];

  if (users[user] && pass === saved) {
    currentUser = user;
    loginSection.style.display = "none";
    appDiv.style.display = "block";
    welcomeUser.textContent = `Welcome, ${user.charAt(0).toUpperCase() + user.slice(1)}`;
    document.getElementById("statsButtons").style.display = "flex";
    ["btnLeagueTable","btnFormGuide","btnPredStats"].forEach(id => {
  const el = document.getElementById(id);
  if (el) el.disabled = false;
});
    document.getElementById("leaderboardOverall").classList.add("hidden");
    document.getElementById("leaderboardOverallLoading").classList.remove("hidden");
    document.getElementById("leaderboardOverall").innerHTML = "";
    document.getElementById("leaderboardWeekly").innerHTML = "";

    if (user === "david") {
      document.getElementById("fixtureEditor").classList.remove("hidden");
      document.getElementById("passwordResetSection").classList.remove("hidden");
      document.getElementById("saveSeasonStatsWrap").classList.remove("hidden");
      populatePasswordResetDropdown();

      const all = await getDocs(collection(db, "fixtures"));
      if (all.empty) {
        for (let gw = 1; gw <= 38; gw++) {
          const id = `${gw}_Team A_Team B_${Date.now() + gw}`;
          await setDoc(doc(db, "fixtures", id), { home: "Team A", away: "Team B", gameweek: gw });
        }
        alert("Auto-generated placeholder fixtures.");
      }
    }

    document.getElementById("loadingOverlay").classList.remove("hidden");

    await determineClosestGameweek();
    await populateGameweekDropdown();
    subscribeToGameweek(currentGameweek);

if (Object.keys(gameweekCache).length > 0) {
  populateGameweekDropdownFromCache();
} else {
  await populateGameweekDropdown(); // ðŸ”¹ queries Firestore and fills dropdown
}
    document.getElementById("loadingOverlay").classList.add("hidden");

    // ðŸ”¹ Start background leaderboard loading (all gameweeks)
    setTimeout(async () => {
      await loadAllGameweekDataForLeaderboards(); // Fetch all gameweek data
      renderLeaderboardsFromLocalCache();         // Populate leaderboard when done
      // Save cache
      sessionStorage.setItem("gameweekCache", JSON.stringify(gameweekCache));
      sessionStorage.setItem("deadlinesByWeek", JSON.stringify(deadlinesByWeek));
    }, 0);

    localStorage.setItem("loggedInUser", user);
    localStorage.setItem("selectedGameweek", currentGameweek);

  } else {
    alert("Invalid login");
  }
};

logoutBtn.onclick = () => {
  localStorage.removeItem("loggedInUser");
  localStorage.removeItem("selectedGameweek");
  location.reload();
};

function getLogoUrl(teamName) {
  return `logos/${teamName
    .toLowerCase()
    .replace(/[^a-z0-9 ]/g, "")  // remove punctuation like apostrophes
    .replace(/\s+/g, "-")}.png`; // replace spaces with dashes
}

async function loadGameweeks() {
const fixtureDocs = await getDocs(collection(db, "fixtures"));
const weeks = [...new Set(fixtureDocs.docs.map(d => d.data().gameweek))]
  .filter(Boolean).sort((a, b) => +a - +b);
  const deadlineDocs = await getDocs(collection(db, "deadlines"));

  deadlinesByWeek = {};
  deadlineDocs.forEach(docSnap => {
    const data = docSnap.data();
    if (data?.deadline) {
      deadlinesByWeek[docSnap.id] = new Date(data.deadline);
    }
  });

  const now = new Date();
  let closestWeek = null, minDiff = Infinity;
  for (let week of weeks) {
    const deadline = deadlinesByWeek[week];
    if (deadline) {
      const diff = Math.abs(deadline - now);
      if (diff < minDiff) {
        minDiff = diff;
        closestWeek = week;
      }
    }
  }

if (!currentGameweek) {
  currentGameweek = closestWeek || weeks[0] || "1";
}
  const gameweekSelect = document.getElementById("gameweekSelect");
  gameweekSelect.innerHTML = weeks.map(w => `<option value="${w}">Gameweek ${w}</option>`).join("");
  gameweekSelect.value = currentGameweek;
  subscribeToGameweek(currentGameweek);
}

document.getElementById("gameweekSelect").onchange = async (e) => {
  currentGameweek = e.target.value;
  localStorage.setItem("selectedGameweek", currentGameweek);
  unsubscribeAll();
  subscribeToGameweek(currentGameweek);
};

let unsubscribeFns = [];

function unsubscribeAll() {
  unsubscribeFns.forEach(fn => fn());
  unsubscribeFns = [];
}

function subscribeToGameweek(gameweek) {
  unsubscribeAll(); // Remove previous listeners

  // ðŸ”„ Fixtures (real-time)
  const qFixtures = query(collection(db, "fixtures"), where("gameweek", "==", gameweek));
  const unsubFixtures = onSnapshot(qFixtures, snapshot => {
    const fixtures = snapshot.docs.map(d => ({ id: d.id, ...d.data() }));
    currentFixtures = fixtures;
    if (!gameweekCache[gameweek]) gameweekCache[gameweek] = {};
    gameweekCache[gameweek].fixtures = fixtures;
    sessionStorage.setItem("gameweekCache", JSON.stringify(gameweekCache));
    renderGameweek();
  });
  unsubscribeFns.push(unsubFixtures);

  // ðŸ”„ Predictions
  const unsubPred = onSnapshot(doc(db, "predictions", gameweek), snap => {
    const data = snap.exists() ? snap.data() : {};
    currentPredictions = data;
    if (!gameweekCache[gameweek]) gameweekCache[gameweek] = {};
    gameweekCache[gameweek].predictions = data;
    sessionStorage.setItem("gameweekCache", JSON.stringify(gameweekCache));
    renderGameweek();
  });
  unsubscribeFns.push(unsubPred);

  // ðŸ”„ Results
  const unsubRes = onSnapshot(doc(db, "results", gameweek), snap => {
    const data = snap.exists() ? snap.data() : {};
    currentResults = data;
    if (!gameweekCache[gameweek]) gameweekCache[gameweek] = {};
    gameweekCache[gameweek].results = data;
    sessionStorage.setItem("gameweekCache", JSON.stringify(gameweekCache));
    renderGameweek();
    renderLeaderboardsFromLocalCache();
  });
  unsubscribeFns.push(unsubRes);

  // ðŸ”„ Deadline
  const unsubDeadline = onSnapshot(doc(db, "deadlines", gameweek), snap => {
    if (snap.exists()) {
      const deadline = snap.data().deadline;
      deadlinesByWeek[gameweek] = new Date(deadline);
      if (!gameweekCache[gameweek]) gameweekCache[gameweek] = {};
      gameweekCache[gameweek].deadline = deadline;
      sessionStorage.setItem("gameweekCache", JSON.stringify(gameweekCache));
      sessionStorage.setItem("deadlinesByWeek", JSON.stringify(deadlinesByWeek));
      document.getElementById("gameweekDeadline").textContent =
        `Deadline: ${new Date(deadline).toLocaleString()}`;
    }
  });
  unsubscribeFns.push(unsubDeadline);
}

function renderGameweek() {
  if (!Array.isArray(currentFixtures)) currentFixtures = [];
  if (!currentPredictions || typeof currentPredictions !== "object") currentPredictions = {};
  if (!currentResults || typeof currentResults !== "object") currentResults = {};

  const fixturesContainer = document.getElementById("fixturesContainer");
  fixturesContainer.innerHTML = "";

  const rawDeadline = deadlinesByWeek[currentGameweek];
  const deadline = rawDeadline instanceof Date ? rawDeadline : new Date(rawDeadline);
  const afterDeadline = deadline && new Date() > deadline;

  // sort by order, then kickoff time, then id
  const fixturesSorted = [...currentFixtures].sort((a, b) => {
    const oa = Number.isFinite(a.order) ? Number(a.order) : Number.POSITIVE_INFINITY;
    const ob = Number.isFinite(b.order) ? Number(b.order) : Number.POSITIVE_INFINITY;
    if (oa !== ob) return oa - ob;
    const ta = (typeof fixtureTimeFromId === "function" ? fixtureTimeFromId(a.id) : 0) || 0;
    const tb = (typeof fixtureTimeFromId === "function" ? fixtureTimeFromId(b.id) : 0) || 0;
    if (ta !== tb) return ta - tb;
    return String(a.id).localeCompare(String(b.id));
  });

  for (const fixture of fixturesSorted) {
    const result = currentResults[fixture.id];
    const pred = currentPredictions[fixture.id]?.[currentUser];
    const isLocked = !!result || afterDeadline;
    const hasPrediction = !!pred;

    const div = document.createElement("div");
    div.className = "border p-3 my-2 bg-white rounded shadow";

    div.innerHTML = `
      <div class="flex flex-col md:flex-row md:justify-between md:items-center gap-2">
        <div class="font-semibold flex flex-wrap items-center">
          <span class="homeTeam flex items-center mr-2">
            <img src="${getLogoUrl(fixture.home)}" alt="${fixture.home}" class="w-5 h-5 mr-1 inline" />
            ${fixture.home}
          </span>
          <span class="mx-1">vs</span>
          <span class="awayTeam flex items-center ml-2">
            <img src="${getLogoUrl(fixture.away)}" alt="${fixture.away}" class="w-5 h-5 mr-1 inline" />
            ${fixture.away}
          </span>
          <button class="historyBtn bg-yellow-100 hover:bg-yellow-200 px-2 py-1 rounded text-xs ml-2 mt-2 md:mt-0">
            Fixture Data
          </button>
        </div>
        ${currentUser === "david" ? `
          <div class="flex gap-2 flex-wrap items-center">
            <label class="text-xs text-gray-500" title="Display order">#</label>
            <input type="number" min="1"
                   value="${Number.isFinite(fixture.order) ? fixture.order : ''}"
                   class="orderInput w-16 border rounded px-2 py-1 text-sm" />
            <button class="editBtn bg-blue-100 hover:bg-blue-200 px-2 py-1 rounded text-sm">Edit</button>
            <button class="deleteFixtureBtn bg-red-100 hover:bg-red-200 px-2 py-1 rounded text-sm">Delete</button>
          </div>` : ""}
      </div>

      <div class="mt-3 flex flex-col md:flex-row gap-4">
        <div>
          <label class="text-sm block mb-1">Your Prediction:</label>
          ${
            isLocked && pred
              ? `<div class="inline-block bg-blue-100 border px-3 py-1 rounded">${pred.home} : ${pred.away}</div>`
              : pred
                ? `<div class="flex flex-wrap items-center gap-2">
                    <input type="number" min="0" class="border p-2 w-16 predHome" value="${pred?.home ?? ""}">
                    <span>:</span>
                    <input type="number" min="0" class="border p-2 w-16 predAway" value="${pred?.away ?? ""}">
                    <button class="savePred bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded text-sm">Save</button>
                    <button class="deletePred bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded text-sm">Delete</button>
                  </div>`
                : isLocked
                  ? `<div class="text-red-500 italic">Not submitted</div>`
                  : `<div class="flex flex-wrap items-center gap-2">
                      <input type="number" min="0" class="border p-2 w-16 predHome" value="">
                      <span>:</span>
                      <input type="number" min="0" class="border p-2 w-16 predAway" value="">
                      <button class="savePred bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded text-sm">Save</button>
                    </div>`
          }
        </div>

        <div>
          ${
            currentUser === "david"
              ? `<label class="text-sm block mb-1">Result:</label>
                 <div class="flex flex-wrap items-center gap-2">
                   <input type="number" min="0" class="border p-2 w-16 resHome" value="${result?.home ?? ""}">
                   <span>:</span>
                   <input type="number" min="0" class="border p-2 w-16 resAway" value="${result?.away ?? ""}">
                   <button class="saveRes bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded text-sm">Save</button>
                   ${result ? `<button class="deleteRes bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded text-sm">Delete</button>` : ""}
                 </div>`
              : result
                ? `<label class="text-sm block mb-1">Result:</label>
                   <div class="bg-gray-200 border px-3 py-1 rounded inline-block">${result.home} : ${result.away}</div>`
                : ""
          }
        </div>
      </div>

      <div class="text-sm mt-3 playersPredictions"></div>
    `;

    fixturesContainer.appendChild(div);

    // --- existing listeners (unchanged) ---
    div.querySelector(".savePred")?.addEventListener("click", async () => {
      const h = div.querySelector(".predHome").value;
      const a = div.querySelector(".predAway").value;
      const snap = await getDoc(doc(db, "predictions", currentGameweek));
      const data = snap.exists() ? snap.data() : {};
      if (!data[fixture.id]) data[fixture.id] = {};
      data[fixture.id][currentUser] = { home: +h, away: +a };
      await updateDoc(doc(db, "predictions", currentGameweek), {
        [`${fixture.id}.${currentUser}`]: { home: +h, away: +a }
      });

      currentPredictions[fixture.id] = { ...currentPredictions[fixture.id], [currentUser]: { home: +h, away: +a } };
      gameweekCache[currentGameweek].predictions = currentPredictions;
      sessionStorage.setItem("gameweekCache", JSON.stringify(gameweekCache));
      renderGameweek();
    });

    div.querySelector(".deletePred")?.addEventListener("click", async () => {
      const snap = await getDoc(doc(db, "predictions", currentGameweek));
      if (!snap.exists()) return;
      const data = snap.data();
      delete data[fixture.id][currentUser];
      if (Object.keys(data[fixture.id]).length === 0) delete data[fixture.id];
      await updateDoc(doc(db, "predictions", currentGameweek), {
        [`${fixture.id}.${currentUser}`]: deleteField()
      });

      if (currentPredictions[fixture.id]) {
        delete currentPredictions[fixture.id][currentUser];
      }
      gameweekCache[currentGameweek].predictions = currentPredictions;
      sessionStorage.setItem("gameweekCache", JSON.stringify(gameweekCache));
      renderGameweek();
    });

    div.querySelector(".saveRes")?.addEventListener("click", async () => {
      const h = div.querySelector(".resHome").value;
      const a = div.querySelector(".resAway").value;
      const snap = await getDoc(doc(db, "results", currentGameweek));
      const data = snap.exists() ? snap.data() : {};
      data[fixture.id] = { home: +h, away: +a };
      await updateDoc(doc(db, "results", currentGameweek), {
        [`${fixture.id}`]: { home: +h, away: +a }
      });

      currentResults[fixture.id] = { home: +h, away: +a };
      gameweekCache[currentGameweek].results = currentResults;
      sessionStorage.setItem("gameweekCache", JSON.stringify(gameweekCache));

      renderGameweek();
      renderLeaderboardsFromLocalCache();
    });

    div.querySelector(".deleteRes")?.addEventListener("click", async () => {
      if (!confirm("Are you sure you want to delete this result?")) return;
      const snap = await getDoc(doc(db, "results", currentGameweek));
      if (!snap.exists()) return;
      const data = snap.data();
      delete data[fixture.id];
      await updateDoc(doc(db, "results", currentGameweek), {
        [`${fixture.id}`]: deleteField()
      });
      delete currentResults[fixture.id];
      gameweekCache[currentGameweek].results = currentResults;
      sessionStorage.setItem("gameweekCache", JSON.stringify(gameweekCache));

      renderGameweek();
      renderLeaderboardsFromLocalCache();
    });

    div.querySelector(".editBtn")?.addEventListener("click", async () => {
      const newHome = prompt("New home team name:", fixture.home)?.trim();
      const newAway = prompt("New away team name:", fixture.away)?.trim();
      if (!newHome || !newAway) return;

      await setDoc(doc(db, "fixtures", fixture.id), {
        home: newHome,
        away: newAway,
        gameweek: currentGameweek
      }, { merge: true }); // keep order safe

      fixture.home = newHome;
      fixture.away = newAway;
      renderGameweek();
    });

    div.querySelector(".deleteFixtureBtn")?.addEventListener("click", async () => {
      if (!confirm("Are you sure you want to delete this fixture?")) return;

      await deleteDoc(doc(db, "fixtures", fixture.id));

      currentFixtures = currentFixtures.filter(f => f.id !== fixture.id);
      gameweekCache[currentGameweek].fixtures = currentFixtures;
      sessionStorage.setItem("gameweekCache", JSON.stringify(gameweekCache));

      renderGameweek();
    });

    // âœ… NEW: save order on change (admin only input)
    div.querySelector(".orderInput")?.addEventListener("change", async (e) => {
      const raw = parseInt(e.target.value, 10);
      const val = Math.max(1, Number.isFinite(raw) ? raw : 1);
      // persist
      await updateDoc(doc(db, "fixtures", fixture.id), { order: val });
      // update local objects
      fixture.order = val;
      const gw = String(currentGameweek);
      if (gameweekCache[gw]?.fixtures) {
        const idx = gameweekCache[gw].fixtures.findIndex(x => x.id === fixture.id);
        if (idx >= 0) gameweekCache[gw].fixtures[idx].order = val;
      }
      // re-render to reflect new ordering
      renderGameweek();
    });

    // Show predictions from others ONLY if this user submitted one or the fixture is not locked
    const predDiv = div.querySelector(".playersPredictions");
    const all = currentPredictions[fixture.id] || {};
    const showOthers = hasPrediction;

    if (showOthers && Object.keys(all).length > 0) {
      let html = `
        <div class="mt-3 border border-gray-300 rounded overflow-hidden">
          <table class="table-auto w-full text-sm">
            <thead class="bg-gray-100 text-left">
              <tr>
                <th class="px-2 py-1">Player</th>
                <th class="px-2 py-1">Prediction</th>
                <th class="px-2 py-1">Points</th>
              </tr>
            </thead>
            <tbody>
      `;
      for (let player in all) {
        const p = all[player];
        const res = currentResults[fixture.id];
        let pts = res ? calculatePoints(p, res) : "-";

        let predictionDisplay = "ðŸ”’";
        if (res || player === currentUser || afterDeadline) {
          predictionDisplay = `${p.home}:${p.away}`;
        }

        let predictionClass = (!res && player !== currentUser && !afterDeadline)
          ? 'text-gray-400 italic'
          : '';

        let tooltip = (!res && player !== currentUser && !afterDeadline)
          ? 'title="Hidden until result is submitted or deadline passed"'
          : '';

        let ptsBgClass = "bg-gray-400";
        if (typeof pts === "number") {
          if (pts === 5) ptsBgClass = "bg-green-600";
          else if (pts >= 2) ptsBgClass = "bg-yellow-500";
          else ptsBgClass = "bg-red-500";
        }

        html += `
          <tr class="hover:bg-gray-50">
            <td class="border-t px-2 py-1">${player.charAt(0).toUpperCase() + player.slice(1)}</td>
            <td class="border-t px-2 py-1">
              <span class="${predictionClass}" ${tooltip}>${predictionDisplay}</span>
            </td>
            <td class="border-t px-2 py-1">
              <span class="px-2 py-1 rounded-full text-white text-xs ${ptsBgClass}">${pts}</span>
            </td>
          </tr>`;
      }
      html += `</tbody></table></div>`;
      predDiv.innerHTML = html;
    } else {
      predDiv.innerHTML = "";
    }
  }

  // Rebuild merged predictions/results/fixtures from all cached gameweeks
  const allPredictions = {};
  const allResults = {};
  const allFixtures = [];

  for (const entry of Object.values(gameweekCache || {})) {
    const fixtures    = Array.isArray(entry?.fixtures) ? entry.fixtures : [];
    const predictions = (entry?.predictions && typeof entry.predictions === "object") ? entry.predictions : {};
    const results     = (entry?.results && typeof entry.results === "object") ? entry.results : {};

    for (const f of fixtures) allFixtures.push(f);

    for (const [fid, preds] of Object.entries(predictions)) {
      allPredictions[fid] = { ...(allPredictions[fid] || {}), ...(preds || {}) };
    }
    for (const [fid, res] of Object.entries(results)) {
      allResults[fid] = res;
    }
  }
}

function calculatePoints(pred, res) {
  let pts = 0;
  if (pred.home === res.home) pts++;
  if (pred.away === res.away) pts++;
  if (Math.sign(pred.home - pred.away) === Math.sign(res.home - res.away)) pts += 2;
  if (pred.home === res.home && pred.away === res.away) pts++;
  return pts;
}

// â€”â€”â€” Helpers â€”â€”â€”
let _seasonStatsCache = null;

async function getSeasonStats() {
  if (_seasonStatsCache) return _seasonStatsCache;
  const s = await getDoc(doc(db, "stats", "season"));
  if (!s.exists()) throw new Error("stats/season not found. Have David pressed 'Compute & Save Season Stats'?");
  _seasonStatsCache = s.data();
  return _seasonStatsCache;
}

function renderFormLetters(arr) {
  return (arr || []).map(r => {
    if (r === "W") return `<span class="text-green-600 font-bold">W</span>`;
    if (r === "L") return `<span class="text-red-600 font-bold">L</span>`;
    return `<span class="text-gray-600 font-bold">D</span>`;
  }).join(" ");
}

function formPoints(arr) {
  return (arr || []).reduce((sum, r) => sum + (r === "W" ? 3 : r === "D" ? 1 : 0), 0);
}

function matchOutcomeFromScore(h, a) {
  if (h > a) return "H";
  if (h < a) return "A";
  return "D";
}
function pointsForOutcome(outcome, asTeam) {
  // asTeam: 'home' or 'away'
  if (outcome === "H") return asTeam === "home" ? 3 : 0;
  if (outcome === "A") return asTeam === "away" ? 3 : 0;
  return 1; // draw
}
function normalizeNameLeague(name) {
  // keep exactly your display names; tweak mappings if needed
  return name;
}

// Extract numeric timestamp from fixture id "..._<ts>"
function fixtureTimeFromId(fixtureId) {
  const tail = fixtureId.split("_").pop();
  const n = Number(tail);
  return Number.isFinite(n) ? n : 0;
}

// ---------- Helpers (add once) ----------

// For the home/away split increment
function addToSplit(split, gf, ga, out, side /* 'home' | 'away' */) {
  split.played++;
  split.gf += gf; split.ga += ga;
  if (out === "H") split.wins++;
  else if (out === "A") split.losses++;
  else split.draws++;
  split.points += (out === "D" ? 1 : (out === "H" ? (side === "home" ? 3 : 0)
                                              : (side === "away" ? 3 : 0)));
}

// Team accumulator now includes home/away splits and YoY bucket
function teamStatsAccumulator() {
  return {
    played: 0, wins: 0, draws: 0, losses: 0,
    gf: 0, ga: 0, gd: 0, points: 0,
    home: { played:0, wins:0, draws:0, losses:0, gf:0, ga:0, points:0 },
    away: { played:0, wins:0, draws:0, losses:0, gf:0, ga:0, points:0 },
    form: [],
    // Year-over-year deltas: sum of (this season âˆ’ 2024/25) result vectors
    yoy: { W:0, D:0, L:0, GF:0, GA:0, Pts:0, missingPrev:0 },
  };
}

// Tiny vector algebra for YoY
function outcomeFromScore(h, a) { return h > a ? "H" : (h < a ? "A" : "D"); }
function tablePoints(outcome, side /* 'home' | 'away' */) {
  if (outcome === "D") return 1;
  if (outcome === "H") return side === "home" ? 3 : 0;
  if (outcome === "A") return side === "away" ? 3 : 0;
  return 0;
}

// --- TEAM-RELATIVE helpers (for YoY only) ---
function outcomeForTeam(gf, ga) {
  // Team-relative outcome: gf/ga are for THIS team
  if (gf > ga) return "W";
  if (gf < ga) return "L";
  return "D";
}

function teamRelativePoints(out /* 'W'|'D'|'L' */) {
  return out === "W" ? 3 : out === "D" ? 1 : 0;
}

// Build a vector from THIS team's perspective (keep signature for compatibility)
function vectorForTeam(side /* 'home'|'away' */, gf, ga) {
  const outT = outcomeForTeam(gf, ga); // 'W' | 'D' | 'L' for THIS team
  return {
    W:  outT === "W" ? 1 : 0,
    D:  outT === "D" ? 1 : 0,
    L:  outT === "L" ? 1 : 0,
    GF: gf,
    GA: ga,
    Pts: teamRelativePoints(outT),
  };
}

function addVec(dst, v, sign = +1) {
  dst.W += sign*v.W; dst.D += sign*v.D; dst.L += sign*v.L;
  dst.GF += sign*v.GF; dst.GA += sign*v.GA; dst.Pts += sign*v.Pts;
}

// Use your normalizeTeam mapping if present (so we match history doc ids)
const HISTORY_NAME_MAP = {
  "Leeds": "Leeds United",
  "Man Utd": "Manchester United",
  "Man City": "Manchester City",
  "Spurs": "Tottenham Hotspur",
  "Wolves": "Wolverhampton Wanderers",
  "West Ham": "West Ham United",
  "Newcastle": "Newcastle United",
 "Nott'm Forest": "Nottingham Forest",
  "Brighton": "Brighton & Hove Albion",
  // add others if you find more short forms in fixtures
};

const _normalizeForHistory = (name) => {
  return HISTORY_NAME_MAP[name] || name;
};

// Cache history reads within a single computation
const _historyDocCache = new Map();

async function getPrevSeasonResult2024_25(home, away) {
  const h = _normalizeForHistory(home);
  const a = _normalizeForHistory(away);
  const key = `${h} vs ${a}`;
  if (_historyDocCache.has(key)) return _historyDocCache.get(key);

  try {
    const snap = await getDoc(doc(db, "history", key));
    if (!snap.exists()) { _historyDocCache.set(key, null); return null; }
    const data = snap.data();
    const arr = Array.isArray(data.last5) ? data.last5 : [];

    // Find exact same-venue entry in season "2024/25"
    const prev = arr.find(m =>
      m.season === "2024/25" &&
      m.home === h &&
      m.away === a &&
      Number.isFinite(m.gh) &&
      Number.isFinite(m.ga)
    );

    const res = prev ? { gh: prev.gh, ga: prev.ga } : null;
    _historyDocCache.set(key, res);
    return res;
  } catch (e) {
    console.warn("history fetch failed for", key, e);
    _historyDocCache.set(key, null);
    return null;
  }
}

// â€”â€”â€” Compute all stats up to currentGameweek â€”â€”â€”
async function computeSeasonStatsUpToCurrentGW() {
  // Ensure cache has all weeks â‰¤ currentGW
  const fixtureDocs = await getDocs(collection(db, "fixtures"));
  const allFixtures = fixtureDocs.docs.map(d => ({ id: d.id, ...d.data() }));
  const allWeeks = [...new Set(allFixtures.map(f => String(f.gameweek)))].filter(Boolean);

  for (const w of allWeeks) {
    if (+w > +currentGameweek) continue;
    if (!gameweekCache[w] || !gameweekCache[w].fixtures) {
      const fixtures = allFixtures.filter(f => String(f.gameweek) === w);
      const [predSnap, resSnap] = await Promise.all([
        getDoc(doc(db, "predictions", w)),
        getDoc(doc(db, "results", w))
      ]);
      gameweekCache[w] = gameweekCache[w] || {};
      gameweekCache[w].fixtures = (fixtures || []).map((f, i) => ({
        ...f,
        order: Number.isFinite(f.order) ? Number(f.order) : (i + 1)
      }));
      gameweekCache[w].predictions = predSnap.exists() ? predSnap.data() : {};
      gameweekCache[w].results     = resSnap.exists() ? resSnap.data() : {};
    }
  }

  // ===== REAL table + helper maps =====
  const teamTable = {};         // team -> aggregates (includes home/away + yoy)
  const teamMatchesChrono = {}; // team -> ['W','D','L',...]
  const teamRealPoints = {};    // team -> real league points tally

  // ===== PREDICTED aggregates =====
  const playerPredictedTeamPointsAll = {};   // user -> team -> { pts,gf,ga,games }
  const playerPredictedTeamPointsScored = {}; // user -> team -> pts (ONLY fixtures WITH result)
  const playerPredictedTeamPoints = {};      // user -> team -> number (ALL predictions; for liked/hated)
  const playerGamePointsByTeam = {};         // user -> team -> number (prediction-game points; ONLY with result)

  const sortedWeeks = Object.keys(gameweekCache)
    .map(String).filter(w => +w <= +currentGameweek)
    .sort((a,b)=> +a - +b);

  // clear per-run cache for history
  _historyDocCache.clear();

  for (const w of sortedWeeks) {
    const { fixtures = [], results = {}, predictions = {} } = gameweekCache[w] || {};
    const fixturesSorted = [...fixtures].sort((a,b) => fixtureTimeFromId(a.id) - fixtureTimeFromId(b.id));

    for (const f of fixturesSorted) {
      const fid = f.id;
      const res = results[fid];
      const home = normalizeNameLeague(f.home);
      const away = normalizeNameLeague(f.away);

      // ensure rows
      teamTable[home] = teamTable[home] || teamStatsAccumulator();
      teamTable[away] = teamTable[away] || teamStatsAccumulator();
      teamMatchesChrono[home] = teamMatchesChrono[home] || [];
      teamMatchesChrono[away] = teamMatchesChrono[away] || [];
      teamRealPoints[home] = teamRealPoints[home] || 0;
      teamRealPoints[away] = teamRealPoints[away] || 0;

      // ----- REAL table (only when result exists)
      if (res && Number.isFinite(res.home) && Number.isFinite(res.away)) {
        const out = matchOutcomeFromScore(res.home, res.away);

        const th = teamTable[home], ta = teamTable[away];
        const homePts = pointsForOutcome(out, "home");
        const awayPts = pointsForOutcome(out, "away");

        th.played++; ta.played++;
        th.gf += res.home; th.ga += res.away;
        ta.gf += res.away; ta.ga += res.home;
        th.gd = th.gf - th.ga; ta.gd = ta.gf - ta.ga;

        if (out === "H") { th.wins++; ta.losses++; }
        else if (out === "A") { ta.wins++; th.losses++; }
        else { th.draws++; ta.draws++; }

        th.points += homePts; ta.points += awayPts;
        teamRealPoints[home] += homePts; teamRealPoints[away] += awayPts;

        // splits
        addToSplit(th.home, res.home, res.away, out, "home");
        addToSplit(ta.away, res.away, res.home, out, "away");

        // form
        teamMatchesChrono[home].push(out === "H" ? "W" : (out === "A" ? "L" : "D"));
        teamMatchesChrono[away].push(out === "A" ? "W" : (out === "H" ? "L" : "D"));

        // ===== YoY vs 2024/25 (NO double counting for Pts) =====
        const curH = vectorForTeam("home", res.home, res.away);
        const curA = vectorForTeam("away", res.away, res.home);

        const prev = await getPrevSeasonResult2024_25(home, away);
        if (prev) {
          const prevH = vectorForTeam("home", prev.gh, prev.ga);
          const prevA = vectorForTeam("away", prev.ga, prev.gh);

          // Net effect: adds this seasonâ€™s stats, subtracts last seasonâ€™s
          addVec(th.yoy, curH, +1); addVec(th.yoy, prevH, -1);
          addVec(ta.yoy, curA, +1); addVec(ta.yoy, prevA, -1);
        } else {
          // Add only this season
          addVec(th.yoy, curH, +1);
          addVec(ta.yoy, curA, +1);
          th.yoy.missingPrev++;
          ta.yoy.missingPrev++;
        }
      }

      // ----- PREDICTED (always add to ALL; add to SCORED only if result exists)
      const predsForFixture = predictions[fid] || {};
      for (const [user, p] of Object.entries(predsForFixture)) {
        if (!p || !Number.isFinite(p.home) || !Number.isFinite(p.away)) continue;

        const predictedOutcome = matchOutcomeFromScore(p.home, p.away);
        const homePredPts = pointsForOutcome(predictedOutcome, "home");
        const awayPredPts = pointsForOutcome(predictedOutcome, "away");

        // ensure user maps
        (playerPredictedTeamPointsAll[user] ||= {});
        (playerPredictedTeamPoints[user]    ||= {});
        (playerPredictedTeamPointsScored[user] ||= {});
        (playerGamePointsByTeam[user] ||= {});

        // ALL predictions â†’ { pts,gf,ga,games } per team
// ALL predictions â†’ { pts,gf,ga,games,wins,draws,losses } per team
const aggH = (playerPredictedTeamPointsAll[user][home] ||= { pts: 0, gf: 0, ga: 0, games: 0, wins: 0, draws: 0, losses: 0 });
const aggA = (playerPredictedTeamPointsAll[user][away] ||= { pts: 0, gf: 0, ga: 0, games: 0, wins: 0, draws: 0, losses: 0 });

aggH.pts += homePredPts;
aggA.pts += awayPredPts;

aggH.gf += p.home;
aggH.ga += p.away;
aggH.games++;

aggA.gf += p.away;
aggA.ga += p.home;
aggA.games++;

// Count W/D/L for predicted outcome
if (predictedOutcome === "H") {
  aggH.wins++;
  aggA.losses++;
} else if (predictedOutcome === "A") {
  aggA.wins++;
  aggH.losses++;
} else {
  aggH.draws++;
  aggA.draws++;
}

        // Simple totals for liked/hated
        playerPredictedTeamPoints[user][home] = (playerPredictedTeamPoints[user][home] || 0) + homePredPts;
        playerPredictedTeamPoints[user][away] = (playerPredictedTeamPoints[user][away] || 0) + awayPredPts;

        // ONLY fixtures with results
        if (res && Number.isFinite(res.home) && Number.isFinite(res.away)) {
          // predicted table points (scored)
          playerPredictedTeamPointsScored[user][home] =
            (playerPredictedTeamPointsScored[user][home] || 0) + homePredPts;
          playerPredictedTeamPointsScored[user][away] =
            (playerPredictedTeamPointsScored[user][away] || 0) + awayPredPts;

          // prediction-game points earned, allocate to both teams
          const pgPts = calculatePoints({ home: p.home, away: p.away }, res);
          playerGamePointsByTeam[user][home] = (playerGamePointsByTeam[user][home] || 0) + pgPts;
          playerGamePointsByTeam[user][away] = (playerGamePointsByTeam[user][away] || 0) + pgPts;
        }
      }
    }
  }

  // ===== Build league table positions from results =====
  const teams = Object.keys(teamTable);
  const tableArr = teams.map(team => ({
    team, ...teamTable[team],
  })).sort((a,b) =>
    b.points - a.points ||
    (b.gf - b.ga) - (a.gf - a.ga) ||
    b.gf - a.gf ||
    a.team.localeCompare(b.team)
  );

  const positionByTeam = {};
  tableArr.forEach((row, i) => positionByTeam[row.team] = i + 1);

  const teamsDoc = {};
  for (const team of teams) {
    const t = teamTable[team];
    const last6 = (teamMatchesChrono[team] || []).slice(-6);
    teamsDoc[team] = {
      form: last6,
      position: positionByTeam[team] || null,
      played: t.played, wins: t.wins, draws: t.draws, losses: t.losses,
      gf: t.gf, ga: t.ga, gd: t.gf - t.ga, points: t.points,
      home: t.home,
      away: t.away,
      yoy: t.yoy // { W,D,L,GF,GA, Pts, missingPrev }
    };
  }

  return {
    currentGameweek: String(currentGameweek),
    teams: teamsDoc,
    teamRealPoints,

    // Per-player outputs
    playerPredictedTeamPoints,         // ALL predictions; liked/hated
    playerPredictedTeamPointsAll,      // ALL predictions with {pts,gf,ga,games}
    playerPredictedTeamPointsScored,   // ONLY fixtures WITH result (predicted table points)
    playerGamePointsByTeam,            // ONLY fixtures WITH result (prediction-game points)
  };
}

async function openLeagueTableModal() {
  const stats = await getSeasonStats();
  const teams = stats.teams || {};
  const teamNames = Object.keys(teams || {});
const lastYearSnap = await getDocs(collection(db, "lastyear"));
const lastYear = Object.fromEntries(lastYearSnap.docs.map(d => [d.id, d.data()]));
  const modes = ["overall", "home", "away", "lastyear"];

  const modeLabels = {
    overall: "Overall",
    home: "Home",
    away: "Away",
    lastyear: "Last Season (adjusted)",
  };

  const buttonsHtml = modes.map(mode => `
    <button class="leagueModeBtn px-3 py-1 rounded border text-sm mr-2 mb-2"
            data-mode="${mode}">
      ${modeLabels[mode]}
    </button>
  `).join("");

  const buildRows = (mode) => {
    return teamNames.map(team => {
      let P = 0, W = 0, D = 0, L = 0, GF = 0, GA = 0, Pts = 0;

      if (mode === "home") {
        const t = teams[team]?.home || {};
        P = t.played ?? t.games ?? 0;
        W = t.wins ?? 0;
        D = t.draws ?? 0;
        L = t.losses ?? 0;
        GF = t.gf ?? 0;
        GA = t.ga ?? 0;
        Pts = t.points ?? 0;
      } else if (mode === "away") {
        const t = teams[team]?.away || {};
        P = t.played ?? t.games ?? 0;
        W = t.losses ?? 0;
        D = t.draws ?? 0;
        L = t.wins ?? 0;
        GF = t.gf ?? 0;
        GA = t.ga ?? 0;
        Pts = t.points ?? 0;
      } else if (mode === "lastyear") {
  const last = lastYear?.[team] || {};
  const yoy = teams?.[team]?.yoy || {};

  const toNum = (x) => Number.isFinite(x) ? x : 0;

  P   = toNum(last.P)   + toNum(yoy.missingPrev);
  W   = toNum(last.W)   + toNum(yoy.W);
  D   = toNum(last.D)   + toNum(yoy.D);
  L   = toNum(last.L)   + toNum(yoy.L);
  GF  = toNum(last.GF)  + toNum(yoy.GF);
  GA  = toNum(last.GA)  + toNum(yoy.GA);
  Pts = toNum(last.Pts) + toNum(yoy.Pts);
      } else {
        const t = teams[team] || {};
        P = t.played ?? t.games ?? 0;
        W = t.wins ?? 0;
        D = t.draws ?? 0;
        L = t.losses ?? 0;
        GF = t.gf ?? 0;
        GA = t.ga ?? 0;
        Pts = t.points ?? 0;
      }

      const GD = GF - GA;

      return { team, P, W, D, L, GF, GA, GD, Pts };
    }).sort((a, b) =>
      b.Pts - a.Pts || b.GD - a.GD || b.GF - a.GF || a.team.localeCompare(b.team)
    ).map((r, i) => `
      <tr class="hover:bg-gray-50">
        <td class="px-1 py-1"><span class="text-red-600 font-bold">${i + 1}.</span></td>
        <td class="px-1 py-1">${r.team}</td>
        <td class="px-1 py-1 text-right">${r.P}</td>
        <td class="px-1 py-1 text-right">${r.W}</td>
        <td class="px-1 py-1 text-right">${r.D}</td>
        <td class="px-1 py-1 text-right">${r.L}</td>
        <td class="px-1 py-1 text-right">${r.GF}-${r.GA}</td>
        <td class="px-1 py-1 text-right">${r.GD}</td>
        <td class="px-1 py-1 text-right font-semibold">${r.Pts}</td>
      </tr>
    `).join("");
  };

  const tableHeader = `
    <thead class="bg-gray-100">
      <tr>
        <th class="px-1 py-1 text-left">#</th>
        <th class="px-1 py-1 text-left">Team</th>
        <th class="px-1 py-1 text-right">P</th>
        <th class="px-1 py-1 text-right">W</th>
        <th class="px-1 py-1 text-right">D</th>
        <th class="px-1 py-1 text-right">L</th>
        <th class="px-1 py-1 text-right">+/-</th>
        <th class="px-1 py-1 text-right">GD</th>
        <th class="px-1 py-1 text-right">Pts</th>
      </tr>
    </thead>
  `;

  const allTablesHtml = modes.map(mode => `
    <div class="leagueTable hidden" data-mode="${mode}">
      <table class="table-auto w-full border text-sm">
        ${tableHeader}
        <tbody>${buildRows(mode)}</tbody>
      </table>
    </div>
  `).join("");

  document.getElementById("statsModalTitle").textContent = `League Table`;
  document.getElementById("statsModalContent").innerHTML = `
    <div class="mb-4 flex flex-wrap">${buttonsHtml}</div>
    <div class="overflow-x-auto">${allTablesHtml}</div>
  `;
  document.getElementById("statsModal").classList.remove("hidden");

  const btns = document.querySelectorAll(".leagueModeBtn");
  const tables = document.querySelectorAll(".leagueTable");
  const activateMode = (mode) => {
    btns.forEach(b => {
      const active = b.dataset.mode === mode;
      b.classList.toggle("bg-blue-600", active);
      b.classList.toggle("text-white", active);
      b.classList.toggle("bg-white", !active);
      b.classList.toggle("text-gray-700", !active);
    });
    tables.forEach(t => {
      t.classList.toggle("hidden", t.dataset.mode !== mode);
    });
  };

  btns.forEach(btn => {
    btn.onclick = () => activateMode(btn.dataset.mode);
  });

  activateMode("overall"); // default
}

async function openFormGuideModal() {
  const stats = await getSeasonStats();
  const teams = stats.teams || {};
  const gw = stats.currentGameweek ?? currentGameweek;

  // sort by form points (last-6), then GD, then GF, then team
  const rows = Object.entries(teams).map(([team, t]) => {
    const form = t.form || [];
    const last6 = form.slice(-6);
    return {
      team,
      pos: t.position ?? 9999,
      last6,
      last6Pts: formPoints(last6),
      gd: t.gd ?? ((t.gf ?? 0)-(t.ga ?? 0)),
      gf: t.gf ?? 0
    };
  }).sort((a,b) =>
    b.last6Pts - a.last6Pts ||
    b.gd - a.gd ||
    b.gf - a.gf ||
    a.team.localeCompare(b.team)
  );

  const list = rows.map(r => `
    <div class="flex items-center justify-between py-1 border-b">
      <div class="flex items-center gap-2">
        <span class="text-red-600 font-bold">${r.pos}.</span>
        <span class="font-medium">${r.team}</span>
      </div>
      <div class="flex items-center gap-3">
        <span class="whitespace-nowrap">${renderFormLetters(r.last6)}</span>
        <span class="text-xs text-gray-600">(${r.last6Pts} pts)</span>
      </div>
    </div>
  `).join("");

  document.getElementById("statsModalTitle").textContent =
    `Form Guide (last 6)`;

  document.getElementById("statsModalContent").innerHTML = `
    <div class="text-sm">
      ${list}
    </div>
  `;

  document.getElementById("statsModal").classList.remove("hidden");
}

function pickTeamsByValue(map, selectorFn) {
  // Returns { value, teams[] } for the chosen selector over the map's values
  const entries = Object.entries(map);
  if (entries.length === 0) return { value: null, teams: [] };
  let bestVal = null;
  let teams = [];
  for (const [team, val] of entries) {
    const v = selectorFn(val);
    if (bestVal === null || v > bestVal) { bestVal = v; teams = [team]; }
    else if (v === bestVal) teams.push(team);
  }
  return { value: bestVal, teams };
}

function pickTeamsByMinAbsDiff(diffMap) {
  // diffMap: team -> absDiff
  const entries = Object.entries(diffMap);
  if (entries.length === 0) return { value: null, teams: [] };
  let best = null, teams = [];
  for (const [team, v] of entries) {
    if (best === null || v < best) { best = v; teams = [team]; }
    else if (v === best) teams.push(team);
  }
  return { value: best, teams };
}

function htmlTeamsList(teams, suffix = "") {
  if (!teams || teams.length === 0) return "â€“";
 return teams.map(t => `<span class="font-medium">${t}</span>`).join(", ");
}

async function openPredictionStatsModal() {
  const stats = await getSeasonStats();
  const gw = stats.currentGameweek ?? currentGameweek;

  const teamRealPoints = (stats.teamRealPoints && Object.keys(stats.teamRealPoints).length)
    ? stats.teamRealPoints
    : Object.fromEntries(
        Object.entries(stats.teams || {}).map(([team, t]) => [team, t.points ?? 0])
      );

  const perPlayerAll    = stats.playerPredictedTeamPointsAll    || {}; // player -> team -> {pts,gf,ga,games,wins,draws,losses}
  const perPlayerScored = stats.playerPredictedTeamPointsScored || {}; // player -> team -> pts

  const realTeamsArray = Object.keys(teamRealPoints);
  const players = Array.from(new Set([
    ...Object.keys(perPlayerAll),
    ...Object.keys(perPlayerScored)
  ])).sort();

  const playerButtons = players.map(player => `
    <button class="playerBtn px-3 py-1 rounded border text-sm mr-2 mb-2"
            data-player="${player}">
      ${player.charAt(0).toUpperCase() + player.slice(1)}
    </button>
  `).join("");

  let playerStatsHtml = "";

  for (const player of players) {
    const tAllRaw = perPlayerAll[player]    || {};
    const tScored = perPlayerScored[player] || {};

    const delta = {}, absDiff = {};
    for (const team of realTeamsArray) {
      const p = tScored[team] ?? 0;
      const r = teamRealPoints[team] ?? 0;
      delta[team] = p - r;
      absDiff[team] = Math.abs(r - p);
    }

    const mostOver = pickTeamsByValue(delta, v => v);
    const mostUnder = (() => {
      const entries = Object.entries(delta);
      if (!entries.length) return { value: null, teams: [] };
      let bestVal = null, teams = [];
      for (const [team, v] of entries) {
        const inv = -v;
        if (bestVal === null || inv > bestVal) { bestVal = inv; teams = [team]; }
        else if (inv === bestVal) teams.push(team);
      }
      return { value: bestVal, teams };
    })();
    const bestPred = pickTeamsByMinAbsDiff(absDiff);

const gamePts = stats.playerGamePointsByTeam?.[player] || {};

const mostPointsTeam = (() => {
  const arr = Object.entries(gamePts);
  if (!arr.length) return { teams: [], value: 0 };
  const max = Math.max(...arr.map(([_, v]) => v));
  const teams = arr.filter(([_, v]) => v === max).map(([team]) => team);
  return { teams, value: max };
})();

const leastPointsTeam = (() => {
  const arr = Object.entries(gamePts);
  if (!arr.length) return { teams: [], value: 0 };
  const min = Math.min(...arr.map(([_, v]) => v));
  const teams = arr.filter(([_, v]) => v === min).map(([team]) => team);
  return { teams, value: min };
})();

    const tAllArray = Object.entries(tAllRaw).map(([team, v]) => {
      const pts = Number(v?.pts ?? 0);
      const gf  = Number(v?.gf  ?? 0);
      const ga  = Number(v?.ga  ?? 0);
      const p   = Number(v?.games ?? 0);
      const w   = Number(v?.wins ?? 0);
      const d   = Number(v?.draws ?? 0);
      const l   = Number(v?.losses ?? 0);
      const gd  = gf - ga;
      return { team, pts, p, w, d, l, gf, ga, gd };
    }).sort((a, b) =>
      b.pts - a.pts ||
      b.gd  - a.gd  ||
      b.gf  - a.gf  ||
      a.team.localeCompare(b.team)
    );

    const tableHtml = tAllArray.length ? `
      <table class="w-full text-sm mt-2 border border-gray-200 rounded overflow-hidden">
        <thead>
          <tr class="bg-gray-50">
            <th class="w-10 text-right px-1 py-1">#</th>
            <th class="text-left px-1 py-1">Team</th>
            <th class="w-8 text-right px-1 py-1">P</th>
            <th class="w-8 text-right px-1 py-1">W</th>
            <th class="w-8 text-right px-1 py-1">D</th>
            <th class="w-8 text-right px-1 py-1">L</th>
            <th class="w-10 text-right px-1 py-1">+/-</th>
            <th class="w-10 text-right px-1 py-1">GD</th>
            <th class="w-10 text-right px-1 py-1">Pts</th>
          </tr>
        </thead>
        <tbody>
          ${tAllArray.map((r, i) => `
            <tr class="${i % 2 ? 'bg-white' : 'bg-gray-50'}">
              <td class="text-right px-1 py-1">${i + 1}</td>
              <td class="px-1 py-1 truncate">${r.team}</td>
              <td class="text-right px-1 py-1">${r.p}</td>
              <td class="text-right px-1 py-1">${r.w}</td>
              <td class="text-right px-1 py-1">${r.d}</td>
              <td class="text-right px-1 py-1">${r.l}</td>
              <td class="text-right px-1 py-1">${r.gf}-${r.ga}</td>
              <td class="text-right px-1 py-1">${r.gd}</td>
              <td class="text-right px-1 py-1 font-semibold">${r.pts}</td>
            </tr>
          `).join("")}
        </tbody>
      </table>
    ` : `<div class="text-sm text-gray-500 mt-2">No predicted table data.</div>`;

    playerStatsHtml += `
      <div class="playerStats hidden" data-player="${player}">
        <div class="text-base font-semibold mb-2">${player.charAt(0).toUpperCase() + player.slice(1)}</div>
        <div class="text-sm space-y-1">
          <div><span class="font-medium">Most overrated team:</span> ${htmlTeamsList(mostOver.teams)} <span class="text-gray-600">(+${mostOver.value ?? 0})</span></div>
          <div><span class="font-medium">Most underrated team:</span> ${htmlTeamsList(mostUnder.teams)} <span class="text-gray-600">(-${mostUnder.value ?? 0})</span></div>
          <div><span class="font-medium">Best predicted team:</span> ${htmlTeamsList(bestPred.teams)} <span class="text-gray-600">(Â±${bestPred.value ?? 0})</span></div>
          <div><span class="font-medium">Most game points:</span> ${htmlTeamsList(mostPointsTeam.teams)} <span class="text-gray-600">(${mostPointsTeam.value ?? 0})</span></div>
          <div><span class="font-medium">Least game points:</span> ${htmlTeamsList(leastPointsTeam.teams)} <span class="text-gray-600">(${leastPointsTeam.value ?? 0})</span></div>
        </div>
        <div class="mt-3">
          <div class="text-sm font-medium mb-1">League table according to predictions</div>
          ${tableHtml}
        </div>
      </div>
    `;
  }

  document.getElementById("statsModalTitle").textContent = `Predictions stats`;
  document.getElementById("statsModalContent").innerHTML = `
    <div class="mb-4 flex flex-wrap">${playerButtons}</div>
    ${playerStatsHtml}
  `;

  document.getElementById("statsModal").classList.remove("hidden");

  const buttons = document.querySelectorAll(".playerBtn");
  const sections = document.querySelectorAll(".playerStats");
  buttons.forEach(btn => btn.classList.add("bg-white", "text-gray-700", "border-gray-300"));
  sections.forEach(div => div.classList.add("hidden"));
  if (buttons[0]) {
    buttons[0].classList.remove("bg-white", "text-gray-700");
    buttons[0].classList.add("bg-blue-600", "text-white");
    document.querySelector(`.playerStats[data-player="${buttons[0].dataset.player}"]`).classList.remove("hidden");
  }

  buttons.forEach(btn => {
    btn.onclick = () => {
      const selected = btn.dataset.player;
      buttons.forEach(b => b.classList.remove("bg-blue-600", "text-white"));
      buttons.forEach(b => b.classList.add("bg-white", "text-gray-700"));
      btn.classList.remove("bg-white", "text-gray-700");
      btn.classList.add("bg-blue-600", "text-white");

      sections.forEach(div => div.classList.add("hidden"));
      document.querySelector(`.playerStats[data-player="${selected}"]`).classList.remove("hidden");
    };
  });
}
    
// Buttons + close
document.getElementById("btnLeagueTable")?.addEventListener("click", () => {
  openLeagueTableModal().catch(err => alert(err.message || String(err)));
});
document.getElementById("btnFormGuide")?.addEventListener("click", () => {
  openFormGuideModal().catch(err => alert(err.message || String(err)));
});
    document.getElementById("btnPredStats")?.addEventListener("click", () => {
  openPredictionStatsModal().catch(err => alert(err.message || String(err)));
});

document.getElementById("closeStatsBtn")?.addEventListener("click", () => {
  document.getElementById("statsModal").classList.add("hidden");
});

    
// â€”â€”â€” Persist to Firestore â€”â€”â€”
async function saveSeasonStatsToFirestore() {
  const statusEl = document.getElementById("saveSeasonStatsStatus");
  try {
    statusEl.textContent = "Computing...";
    const payload = await computeSeasonStatsUpToCurrentGW();

    await setDoc(doc(db, "stats", "season"), {
      ...payload,
      updatedAt: new Date().toISOString()
    }, { merge: true });

    // clear local cache so next read pulls fresh doc
    _seasonStatsCache = null;

    statusEl.textContent = "âœ… Saved season stats.";
    setTimeout(() => statusEl.textContent = "", 3000);
  } catch (e) {
    console.error(e);
    statusEl.textContent = "âŒ Failed to save season stats. See console.";
    setTimeout(() => statusEl.textContent = "", 6000);
  }
}

    
function renderLeaderboards(allPredictions, allResults, allFixtures) {
  const overall = {}, exacts = {}, outcomes = {}, counts = {};
  const weekly = {}, wExacts = {}, wOutcomes = {}, wCounts = {};

  for (let fixture of allFixtures) {
    const fid = fixture.id;
    const res = allResults[fid];
    if (!res) continue;
    const preds = allPredictions[fid] || {};

    const isCurrentWeek = fixture.gameweek == currentGameweek;

    for (let user in preds) {
      const pts = calculatePoints(preds[user], res);
      const isExact = pts === 5;
      const isOutcome = pts >= 2;

      // Overall leaderboard
      overall[user] = (overall[user] || 0) + pts;
      counts[user] = (counts[user] || 0) + 1;
      if (isExact) exacts[user] = (exacts[user] || 0) + 1;
      if (isOutcome) outcomes[user] = (outcomes[user] || 0) + 1;

      // Weekly leaderboard (only current gameweek)
      if (isCurrentWeek) {
        weekly[user] = (weekly[user] || 0) + pts;
        wCounts[user] = (wCounts[user] || 0) + 1;
        if (isExact) wExacts[user] = (wExacts[user] || 0) + 1;
        if (isOutcome) wOutcomes[user] = (wOutcomes[user] || 0) + 1;
      }
    }
  }

  const render = (points, e = {}, o = {}, c = {}) =>
    `<table class="table-auto border w-full text-sm">
      <thead>
        <tr class="bg-gray-200">
          <th class="border px-2 py-1">Player</th>
          <th class="border px-2 py-1">Pts</th>
          <th class="border px-2 py-1">Exact (5)</th>
          <th class="border px-2 py-1">Outcome (2+)</th>
        </tr>
      </thead>
      <tbody>
        ${Object.entries(points).sort((a,b)=>b[1]-a[1]).map(([u,p]) => {
          const ex = e[u] || 0;
          const ou = o[u] || 0;
          const total = c[u] || 0;
          return `<tr class="text-center">
            <td class="border px-2 py-1">${u.charAt(0).toUpperCase() + u.slice(1)}</td>
            <td class="border px-2 py-1 font-semibold">${p}</td>
            <td class="border px-2 py-1">${ex} (${total ? Math.round(ex/total*100) : 0}%)</td>
            <td class="border px-2 py-1">${ou} (${total ? Math.round(ou/total*100) : 0}%)</td>
          </tr>`;
        }).join("")}
      </tbody>
    </table>`;

  document.getElementById("leaderboardOverall").innerHTML = render(overall, exacts, outcomes, counts);
  document.getElementById("leaderboardWeekly").innerHTML = render(weekly, wExacts, wOutcomes, wCounts);

  // âœ… Show overall leaderboard once it's accurate
document.getElementById("leaderboardOverall").classList.remove("hidden");
document.getElementById("leaderboardOverallLoading").classList.add("hidden");
}

function populatePasswordResetDropdown() {
  document.getElementById("resetUserSelect").innerHTML =
    Object.keys(users).map(u => `<option value="${u}">${u.charAt(0).toUpperCase() + u.slice(1)}</option>`).join("");
}

document.getElementById("resetPasswordBtn").onclick = async () => {
  const user = document.getElementById("resetUserSelect").value;
  const pass = document.getElementById("newPasswordInput").value.trim();
  if (!pass) return alert("Enter new password");
  await setDoc(doc(db, "passwords", user), { password: pass });
  alert("Password updated");
  document.getElementById("newPasswordInput").value = "";
};

document.getElementById("addFixtureBtn").onclick = async () => {
  const home = document.getElementById("newHomeTeam").value.trim();
  const away = document.getElementById("newAwayTeam").value.trim();
  if (!home || !away) return alert("Enter both teams");

  // determine next order
  const gwFixtures = gameweekCache[currentGameweek]?.fixtures || [];
  const existingOrders = gwFixtures
    .map(f => Number(f.order))
    .filter(n => Number.isFinite(n));
  const nextOrder = existingOrders.length ? Math.max(...existingOrders) + 1 : gwFixtures.length + 1;

  const id = `${currentGameweek}_${home}_${away}_${Date.now()}`;
  await setDoc(doc(db, "fixtures", id), {
    home,
    away,
    gameweek: currentGameweek, // âœ… Required for onSnapshot to work
    order: nextOrder           // âœ… NEW
  });

  // Clear input fields
  document.getElementById("newHomeTeam").value = "";
  document.getElementById("newAwayTeam").value = "";

  // If you rely on onSnapshot to refill cache, you *can* clear it:
  // delete gameweekCache[currentGameweek];

  // Re-render for instant feedback
  renderGameweek();
}; // âœ… this is the only closing brace you need

document.getElementById("setDeadlineBtn").onclick = async () => {
  const deadline = document.getElementById("deadlineInput").value;
  if (!deadline) return;

  // âœ… Save to Firestore (this will trigger onSnapshot)
  await setDoc(doc(db, "deadlines", currentGameweek), { deadline });

  // âœ… Update local cache
  deadlinesByWeek[currentGameweek] = new Date(deadline);

  if (!gameweekCache[currentGameweek]) gameweekCache[currentGameweek] = {};
  gameweekCache[currentGameweek].deadline = deadline;

  // âœ… Save to sessionStorage
  sessionStorage.setItem("gameweekCache", JSON.stringify(gameweekCache));
  sessionStorage.setItem("deadlinesByWeek", JSON.stringify(deadlinesByWeek));

  // âŒ DON'T re-subscribe â€“ live updates are automatic
  // âœ… Just update UI locally (optional)
  renderGameweek();
};

// Show history modal
const teamNameMap = {
  "Man Utd": "Manchester United",
  "Man City": "Manchester City",
  "Spurs": "Tottenham Hotspur",
  "Wolves": "Wolverhampton Wanderers",
  "Newcastle": "Newcastle United",
  "West Ham": "West Ham United",
  "Nott'm Forest": "Nottingham Forest",
  "Sheff Utd": "Sheffield United",
  "Leeds": "Leeds United",
  "Brighton": "Brighton & Hove Albion"
};

function normalizeTeam(name) {
  return teamNameMap[name] || name;
}

document.addEventListener("click", async (e) => {
  if (!e.target.classList.contains("historyBtn")) return;
  const card = e.target.closest(".border.p-3");
  const rawHome = card.querySelector(".homeTeam").textContent.trim();
  const rawAway = card.querySelector(".awayTeam").textContent.trim();
  const home = normalizeTeam(rawHome);
  const away = normalizeTeam(rawAway);
  const key = `${home} vs ${away}`;
  const snap = await getDoc(doc(db, "history", key));
  const modal = document.getElementById("historyModal");
  const content = document.getElementById("historyContent");

  if (!snap.exists()) {
    content.textContent = `No history found for ${home} vs ${away}`;
  } else {
    const data = snap.data();
    let html = `ðŸ“Š Head-to-Head: ${home} vs ${away}\n\n`;

    // ðŸ”¹ Fetch season stats (league table + form)	
    let statsDoc;
    try {
      const statsSnap = await getDoc(doc(db, "stats", "season"));
      if (statsSnap.exists()) statsDoc = statsSnap.data();
    } catch (err) {
      console.error("Stats fetch failed", err);
    }

    const gwNumber = statsDoc?.currentGameweek ?? currentGameweek;
    
    if (statsDoc?.teams) {
      const tHome = statsDoc.teams[rawHome];
      const tAway = statsDoc.teams[rawAway];

      // Form guide renderer
      function renderForm(arr) {
        return (arr || []).map(r => {
          if (r === "W") return `<span class="text-green-600 font-bold">W</span>`;
          if (r === "L") return `<span class="text-red-600 font-bold">L</span>`;
          return `<span class="text-gray-600 font-bold">D</span>`;
        }).join(" ");
      }

      html += `Form Guide:\n- ${home}: ${renderForm(tHome?.form)}\n- ${away}: ${renderForm(tAway?.form)}\n\n`;


function renderPosition(pos) {
  if (!pos) return "-";
  return `<span class="text-red-600 font-bold">${pos}.</span>`;
}

html += `League Position:\n` +
        `- ${home}: ${renderPosition(tHome?.position)} (${tHome?.points ?? 0} pts)\n` +
        `- ${away}: ${renderPosition(tAway?.position)} (${tAway?.points ?? 0} pts)\n\n`;      
    }

   
    // Last 5 matches
    html += "Last 5 matches:\n";
    if (data.last5?.length) {
      data.last5.forEach(m => {
        const season = m.season || "â€“";
        html += `â€¢ ${m.home} ${m.gh}-${m.ga} ${m.away} (${season})\n`;
      });
    } else {
      html += "No recent matches found.\n";
    }

    // Summary
    const s = data.summary;
    const total = s.wins + s.draws + s.losses;
    html += `\nSummary:\n- Total matches: ${total}\n- ${home} Wins: ${s.wins}\n- Draws: ${s.draws}\n- ${away} Wins: ${s.losses}`;
    html += `\n- ${home} Goals: ${s.goalsFor}\n- ${away} Goals: ${s.goalsAgainst}`;

    // Biggest Wins
    html += `\n\nBiggest Wins:\n- ${home}: ${data.biggestWin?.[home] || "â€“"}\n- ${away}: ${data.biggestWin?.[away] || "â€“"}`;

    // Longest Streaks
    const hs = data.streaks?.[home];
    const as = data.streaks?.[away];
    html += `\n\nLongest Winning Streaks:\n- ${home}: ${hs?.count || 0} (${hs?.span || "â€“"})\n- ${away}: ${as?.count || 0} (${as?.span || "â€“"})`;

    content.innerHTML = html.replace(/\n/g, "<br>");
  }

  modal.classList.remove("hidden");
});

document.getElementById("closeHistoryBtn").onclick = () =>
  document.getElementById("historyModal").classList.add("hidden");

function renderLeaderboardsFromLocalCache() {
   const leaderboardEl = document.getElementById("leaderboardOverall");
  const loadingEl = document.getElementById("leaderboardOverallLoading");

  // Hide while rendering
  leaderboardEl.classList.add("hidden");
  loadingEl.classList.remove("hidden");
  const allPredictions = {};
  const allResults = {};
  const allFixtures = [];

  for (const week of Object.keys(gameweekCache)) {
    const { fixtures, predictions, results } = gameweekCache[week];

    for (const fixture of fixtures || []) {
      allFixtures.push(fixture);
      const fid = fixture.id;
      if (predictions?.[fid]) allPredictions[fid] = predictions[fid];
      if (results?.[fid]) allResults[fid] = results[fid];
    }
  }

  renderLeaderboards(allPredictions, allResults, allFixtures);
    leaderboardEl.classList.remove("hidden");
  loadingEl.classList.add("hidden");

}

// ðŸ” Clear sessionStorage unless it's a full reload (Ctrl+Shift+R)
if (performance?.navigation?.type !== 1) {
  sessionStorage.clear();
}

document.getElementById("saveSeasonStatsBtn")?.addEventListener("click", () => {
  if (!confirm(`Compute & save season stats up to GW ${currentGameweek}?`)) return;
  saveSeasonStatsToFirestore();
});

    
window.addEventListener("DOMContentLoaded", async () => {
  const savedUser = localStorage.getItem("loggedInUser");
  const savedGameweek = localStorage.getItem("selectedGameweek");

  // Restore gameweekCache from sessionStorage if it exists
  const savedCache = sessionStorage.getItem("gameweekCache");
  const savedDeadlines = sessionStorage.getItem("deadlinesByWeek");

  if (savedCache) {
    try {
      gameweekCache = JSON.parse(savedCache);
    } catch (e) {
      console.error("Failed to parse cached gameweek data", e);
    }
  }

  if (savedDeadlines) {
    try {
      const raw = JSON.parse(savedDeadlines);
      // Convert string timestamps back to Date objects
      for (const [week, dateStr] of Object.entries(raw)) {
        deadlinesByWeek[week] = new Date(dateStr);
      }
    } catch (e) {
      console.error("Failed to parse cached deadlines", e);
    }
  }

  if (savedUser && users[savedUser]) {
    currentUser = savedUser;
if (savedGameweek) {
  currentGameweek = savedGameweek;
} else {
  await determineClosestGameweek();
}

    loginSection.style.display = "none";
    appDiv.style.display = "block";
    welcomeUser.textContent = `Welcome, ${savedUser.charAt(0).toUpperCase() + savedUser.slice(1)}`;
document.getElementById("statsButtons").style.display = "flex";
["btnLeagueTable", "btnFormGuide", "btnPredStats"].forEach(id => {
  const el = document.getElementById(id);
  if (el) {
    el.classList.remove("hidden");
    el.disabled = false;
    el.style.display = "inline-block"; // ðŸ’¥ enforce visibility
  }
});

    if (savedUser === "david") {
      document.getElementById("fixtureEditor").classList.remove("hidden");
      document.getElementById("passwordResetSection").classList.remove("hidden");
      populatePasswordResetDropdown();
    }

    document.getElementById("loadingOverlay").classList.remove("hidden");

    // If cache is empty, do full Firestore load
    if (Object.keys(gameweekCache).length === 0) {
      await loadAllGameweekDataForLeaderboards();
      await populateGameweekDropdown();
    } else {
      populateGameweekDropdownFromCache();
      renderLeaderboardsFromLocalCache();
    }

    subscribeToGameweek(currentGameweek);


    document.getElementById("loadingOverlay").classList.add("hidden");
  }
});

</script>
</body>
</html>
