<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Premier League Predictor</title>
  <script type="module" src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script type="module" src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
  <script type="module" src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
 <style>
  /* Force styles just for the Predictions stats button */
  #btnPredStats {
    background-color: #4f46e5 !important; /* indigo-600 */
    color: #ffffff !important;
    padding: 0.25rem 0.75rem !important;  /* py-1 px-3 */
    border-radius: 0.25rem !important;    /* rounded */
    display: inline-block !important;
    opacity: 1 !important;
    pointer-events: auto !important;
    filter: none !important;
  }
  #btnPredStats:hover {
    background-color: #4338ca !important; /* indigo-700 */
  }
</style>
  <style>
    input[type="number"]::-webkit-inner-spin-button,
    input[type="number"]::-webkit-outer-spin-button {
      opacity: 1;
    }
  </style>
</head>
<body class="bg-gray-100 text-gray-800">

<!-- Loading Overlay -->
<div id="loadingOverlay" class="fixed inset-0 bg-white bg-opacity-80 flex items-center justify-center z-50 hidden">
  <div class="bg-white border border-gray-300 rounded px-6 py-4 shadow text-lg font-semibold">
    Loading fixtures, please wait...
  </div>
</div>

<!-- History Modal -->
<div id="historyModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
  <div class="bg-white p-6 rounded shadow-lg max-w-lg w-full">
    <h2 class="text-lg font-semibold mb-4">Fixture Data</h2>
    <div id="historyContent" class="text-sm max-h-80 overflow-y-auto whitespace-pre-wrap"></div>
    <button id="closeHistoryBtn" class="mt-4 bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded">Close</button>
  </div>
</div>

  <div class="max-w-5xl mx-auto p-4">
    <h1 class="text-2xl font-bold mb-4 text-center">Premier League Prediction Game</h1>

    <!-- LOGIN + CHANGE PASSWORD SECTION -->
    <div id="loginSection" class="mb-6 space-y-4">
      <div>
        <select id="username" class="border p-2 mr-2">
          <option value="" disabled selected>Select user</option>
          <option value="david">David</option>
          <option value="katja">Katja</option>
          <option value="mark">Mark</option>
          <option value="jus">Jus</option>
        </select>
        <input id="password" type="password" class="border p-2 mr-2" placeholder="Password" />
        <button id="loginBtn" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded">Login</button>
      </div>
      <div class="text-sm">
        <button id="showChangePwBtn" class="text-blue-500 hover:underline">Change password</button>
      </div>
      <div id="changePwSection" class="hidden space-y-2">
        <h3 class="font-semibold">Change Password</h3>
        <input id="oldPw" type="password" class="border p-2 w-full" placeholder="Old Password" />
        <input id="newPw" type="password" class="border p-2 w-full" placeholder="New Password" />
        <button id="changePwBtn" class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded">Change Password</button>
      </div>
    </div>
    <!-- APP UI -->
    <div id="app" style="display:none;">
      <div class="flex justify-between items-center mb-4">
        <span id="welcomeUser" class="font-semibold"></span>
        <button id="logoutBtn" class="bg-gray-500 hover:bg-gray-600 text-white px-3 py-1 rounded">Logout</button>
      </div>

      <!-- Gameweek Selector -->
      <div class="mb-4 flex items-center">
        <label for="gameweekSelect" class="mr-2 font-medium">Gameweek:</label>
        <select id="gameweekSelect" class="border p-2"></select>
        <span id="gameweekDeadline" class="ml-4 text-sm text-gray-600"></span>
      </div>
      <!-- Stats buttons (visible to all logged-in users) -->
<div id="statsButtons" class="mb-4 flex gap-2" style="display:none;">
  <button id="btnLeagueTable" class="bg-indigo-600 hover:bg-indigo-700 text-white px-3 py-1 rounded text-sm">League Table</button>
  <button id="btnFormGuide"  class="bg-indigo-700 hover:bg-indigo-800 text-white px-3 py-1 rounded text-sm">Form Guide</button>
  <button id="btnPredStats" class="bg-indigo-600 hover:bg-indigo-700 text-white px-3 py-1 rounded text-sm">Predictions stats</button>
</div>

<!-- Stats Modal -->
<div id="statsModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
  <div class="bg-white p-6 rounded shadow-lg max-w-3xl w-full">
    <h2 id="statsModalTitle" class="text-lg font-semibold mb-4"></h2>
    <div id="statsModalContent" class="text-sm max-h-96 overflow-y-auto"></div>
    <button id="closeStatsBtn" class="mt-4 bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded">Close</button>
  </div>
</div>

 <div id="fixtureEditor" class="mb-6 hidden">
  <h2 class="text-lg font-semibold mb-2">Edit Fixtures</h2>

  <!-- Add Fixture -->
  <div class="grid grid-cols-1 gap-2 sm:grid-cols-3 sm:gap-3">
    <input id="newHomeTeam"
           class="w-full min-w-0 border rounded px-2 py-2 text-sm"
           placeholder="Home Team" />
    <input id="newAwayTeam"
           class="w-full min-w-0 border rounded px-2 py-2 text-sm"
           placeholder="Away Team" />
    <button id="addFixtureBtn"
            class="w-full sm:w-auto px-3 py-2 rounded bg-green-500 hover:bg-green-600 text-white text-sm">
      Add Fixture
    </button>
  </div>

  <!-- Deadline -->
  <div class="mt-3 grid grid-cols-1 gap-2 sm:grid-cols-3 sm:gap-3">
    <label for="deadlineInput" class="text-sm text-gray-700 self-center">Deadline:</label>
    <input type="datetime-local" id="deadlineInput"
           class="w-full min-w-0 border rounded px-2 py-2 text-sm" />
    <button id="setDeadlineBtn"
            class="w-full sm:w-auto px-3 py-2 rounded bg-blue-500 hover:bg-blue-600 text-white text-sm">
      Set Deadline
    </button>
  </div>
</div>


      <!-- Fixtures -->
      <div id="fixturesContainer" class="mb-8"></div>

      <!-- Leaderboards -->
      <div class="mb-6">
        <h2 class="text-lg font-semibold mb-2">Overall Leaderboard</h2>
        <div id="leaderboardOverallContainer">
<div id="leaderboardOverallLoading" class="flex justify-center my-4">
  <div class="animate-spin rounded-full h-6 w-6 border-t-2 border-b-2 border-gray-600"></div>
  <span class="ml-2 text-gray-600 text-sm self-center">Loading leaderboard...</span>
</div>
  <div id="leaderboardOverall" class="overflow-x-auto hidden"></div>
</div>

        <h2 class="text-lg font-semibold mt-6 mb-2">Weekly Leaderboard</h2>
        <div id="leaderboardWeekly" class="overflow-x-auto"></div>
      </div>

<!-- Save Season Stats (David only) -->
<div id="saveSeasonStatsWrap" class="mb-6 hidden">
  <button id="saveSeasonStatsBtn" class="bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded">
    Compute & Save Season Stats (to current GW)
  </button>
  <span id="saveSeasonStatsStatus" class="ml-3 text-sm text-gray-600"></span>
</div>
      
      <!-- Password Reset (David) -->
      <div id="passwordResetSection" class="hidden mb-8">
        <h2 class="text-lg font-semibold mb-2">Reset Player Password</h2>
        <select id="resetUserSelect" class="border p-2 mr-2"></select>
        <input id="newPasswordInput" class="border p-2 mr-2" placeholder="New Password" />
        <button id="resetPasswordBtn" class="bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded">Reset Password</button>
      </div>
    </div>
  </div>
  <script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
import { getFirestore, doc, setDoc, getDoc, collection, getDocs, deleteDoc, query, where, onSnapshot, updateDoc, deleteField } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyA2WG0LUwLCDqmylgezCZ0aH5Q8vTaXTKU",
  authDomain: "pl-predictor-13a6d.firebaseapp.com",
  projectId: "pl-predictor-13a6d",
  storageBucket: "pl-predictor-13a6d.appspot.com",
  messagingSenderId: "286908896536",
  appId: "1:286908896536:web:dabd76b4faaa72a98cfa6d"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

const users = { david:"david123", katja:"katja123", mark:"mark123", jus:"jus123" };

let currentUser="", currentGameweek="", deadlinesByWeek={};
let gameweekCache = {};
let currentFixtures = [], currentPredictions = {}, currentResults = {};

let cachedFixtures = [];
let cachedPredictions = {};
let cachedResults = {};

const loginBtn = document.getElementById("loginBtn");
const showChangePwBtn = document.getElementById("showChangePwBtn");
const changePwSection = document.getElementById("changePwSection");
const oldPw = document.getElementById("oldPw");
const newPw = document.getElementById("newPw");
const changePwBtn = document.getElementById("changePwBtn");
const logoutBtn = document.getElementById("logoutBtn");
const appDiv = document.getElementById("app");
const loginSection = document.getElementById("loginSection");
const welcomeUser = document.getElementById("welcomeUser");

// Toggle change-password form
showChangePwBtn.onclick = () => changePwSection.classList.toggle("hidden");

// Handle password change
changePwBtn.onclick = async () => {
  const user = document.getElementById("username").value;
  const oldPass = oldPw.value, newPass = newPw.value;
  if (!user || !oldPass || !newPass) return alert("Fill all fields");
  const snap = await getDoc(doc(db,"passwords",user));
  const saved = snap.exists() ? snap.data().password : users[user];
  if (oldPass !== saved) return alert("Old password is incorrect");
  await setDoc(doc(db,"passwords",user),{password:newPass});
  alert("Password changed!");
  oldPw.value=""; newPw.value="";
};

async function preloadAllGameweeks() {
  const fixtureDocs = await getDocs(collection(db, "fixtures"));
  const allFixtures = fixtureDocs.docs.map(d => ({ id: d.id, ...d.data() }));
  const weeks = [...new Set(allFixtures.map(f => f.gameweek))].filter(Boolean);

  const deadlinesSnap = await getDocs(collection(db, "deadlines"));
  const deadlineMap = {};
  deadlinesSnap.forEach(doc => {
    if (doc.exists()) deadlineMap[doc.id] = doc.data().deadline;
  });

  for (let week of weeks) {
    const fixtures = allFixtures.filter(f => f.gameweek === week);
    const predictionsSnap = await getDoc(doc(db, "predictions", week));
    const resultsSnap = await getDoc(doc(db, "results", week));
    const predictions = predictionsSnap.exists() ? predictionsSnap.data() : {};
    const results = resultsSnap.exists() ? resultsSnap.data() : {};
    const deadline = deadlineMap[week] || null;

    gameweekCache[week] = { fixtures, predictions, results, deadline };
  }
}

async function loadAllGameweekDataForLeaderboards() {
  const fixtureDocs = await getDocs(collection(db, "fixtures"));
  const allFixtures = fixtureDocs.docs.map(d => ({ id: d.id, ...d.data() }));
  const weeks = [...new Set(allFixtures.map(f => f.gameweek))].filter(Boolean);

  const deadlineSnap = await getDocs(collection(db, "deadlines"));
  deadlineSnap.forEach(doc => {
    if (doc.exists()) {
      deadlinesByWeek[doc.id] = new Date(doc.data().deadline);
    }
  });

  for (let week of weeks) {
    if (!gameweekCache[week]) gameweekCache[week] = {};
    const fixtures = allFixtures.filter(f => f.gameweek === week);

    const [predSnap, resSnap] = await Promise.all([
      getDoc(doc(db, "predictions", week)),
      getDoc(doc(db, "results", week))
    ]);

    gameweekCache[week].fixtures = fixtures;
    gameweekCache[week].predictions = predSnap.exists() ? predSnap.data() : {};
    gameweekCache[week].results = resSnap.exists() ? resSnap.data() : {};
  }

  // ✅ Only now is it safe to render
  renderLeaderboardsFromLocalCache();
sessionStorage.setItem("gameweekCache", JSON.stringify(gameweekCache));
sessionStorage.setItem("deadlinesByWeek", JSON.stringify(deadlinesByWeek));

}

async function determineClosestGameweek() {
  const fixtureDocs = await getDocs(collection(db, "fixtures"));
  const weeks = [...new Set(fixtureDocs.docs.map(d => d.data().gameweek))]
    .filter(Boolean).sort((a, b) => +a - +b);

  const deadlineDocs = await getDocs(collection(db, "deadlines"));
  deadlinesByWeek = {};
  deadlineDocs.forEach(docSnap => {
    const data = docSnap.data();
    if (data?.deadline) {
      deadlinesByWeek[docSnap.id] = new Date(data.deadline);
    }
  });

  const now = new Date();
  let closestWeek = null, minDiff = Infinity;
  for (let week of weeks) {
    const deadline = deadlinesByWeek[week];
    if (deadline) {
      const diff = Math.abs(deadline - now);
      if (diff < minDiff) {
        minDiff = diff;
        closestWeek = week;
      }
    }
  }

  currentGameweek = closestWeek || weeks[0] || "1";
}

async function populateGameweekDropdown() {
  const fixtureDocs = await getDocs(collection(db, "fixtures"));
  const weeks = [...new Set(fixtureDocs.docs.map(d => d.data().gameweek))]
    .filter(Boolean).sort((a, b) => +a - +b);

  const select = document.getElementById("gameweekSelect");
  select.innerHTML = weeks.map(w =>
    `<option value="${w}" ${w == currentGameweek ? "selected" : ""}>Gameweek ${w}</option>`
  ).join("");
}

function populateGameweekDropdownFromCache() {
  const weeks = Object.keys(gameweekCache).sort((a, b) => +a - +b);
  const select = document.getElementById("gameweekSelect");
  select.innerHTML = weeks.map(w =>
    `<option value="${w}" ${w == currentGameweek ? "selected" : ""}>Gameweek ${w}</option>`
  ).join("");
}


loginBtn.onclick = async () => {
  const user = document.getElementById("username").value;
  const pass = document.getElementById("password").value;
  const snap = await getDoc(doc(db, "passwords", user));
  const saved = snap.exists() ? snap.data().password : users[user];

  if (users[user] && pass === saved) {
    currentUser = user;
    loginSection.style.display = "none";
    appDiv.style.display = "block";
    welcomeUser.textContent = `Welcome, ${user.charAt(0).toUpperCase() + user.slice(1)}`;
    document.getElementById("statsButtons").style.display = "flex";
    ["btnLeagueTable","btnFormGuide","btnPredStats"].forEach(id => {
  const el = document.getElementById(id);
  if (el) el.disabled = false;
});
    document.getElementById("leaderboardOverall").classList.add("hidden");
    document.getElementById("leaderboardOverallLoading").classList.remove("hidden");
    document.getElementById("leaderboardOverall").innerHTML = "";
    document.getElementById("leaderboardWeekly").innerHTML = "";

    if (user === "david") {
      document.getElementById("fixtureEditor").classList.remove("hidden");
      document.getElementById("passwordResetSection").classList.remove("hidden");
      document.getElementById("saveSeasonStatsWrap").classList.remove("hidden");
      populatePasswordResetDropdown();

      const all = await getDocs(collection(db, "fixtures"));
      if (all.empty) {
        for (let gw = 1; gw <= 38; gw++) {
          const id = `${gw}_Team A_Team B_${Date.now() + gw}`;
          await setDoc(doc(db, "fixtures", id), { home: "Team A", away: "Team B", gameweek: gw });
        }
        alert("Auto-generated placeholder fixtures.");
      }
    }

    document.getElementById("loadingOverlay").classList.remove("hidden");

    await determineClosestGameweek();
    await populateGameweekDropdown();
    subscribeToGameweek(currentGameweek);

if (Object.keys(gameweekCache).length > 0) {
  populateGameweekDropdownFromCache();
} else {
  await populateGameweekDropdown(); // 🔹 queries Firestore and fills dropdown
}
    document.getElementById("loadingOverlay").classList.add("hidden");

    // 🔹 Start background leaderboard loading (all gameweeks)
    setTimeout(async () => {
      await loadAllGameweekDataForLeaderboards(); // Fetch all gameweek data
      renderLeaderboardsFromLocalCache();         // Populate leaderboard when done
      // Save cache
      sessionStorage.setItem("gameweekCache", JSON.stringify(gameweekCache));
      sessionStorage.setItem("deadlinesByWeek", JSON.stringify(deadlinesByWeek));
    }, 0);

    localStorage.setItem("loggedInUser", user);
    localStorage.setItem("selectedGameweek", currentGameweek);

  } else {
    alert("Invalid login");
  }
};

logoutBtn.onclick = () => {
  localStorage.removeItem("loggedInUser");
  localStorage.removeItem("selectedGameweek");
  location.reload();
};

function getLogoUrl(teamName) {
  return `logos/${teamName
    .toLowerCase()
    .replace(/[^a-z0-9 ]/g, "")  // remove punctuation like apostrophes
    .replace(/\s+/g, "-")}.png`; // replace spaces with dashes
}

async function loadGameweeks() {
const fixtureDocs = await getDocs(collection(db, "fixtures"));
const weeks = [...new Set(fixtureDocs.docs.map(d => d.data().gameweek))]
  .filter(Boolean).sort((a, b) => +a - +b);
  const deadlineDocs = await getDocs(collection(db, "deadlines"));

  deadlinesByWeek = {};
  deadlineDocs.forEach(docSnap => {
    const data = docSnap.data();
    if (data?.deadline) {
      deadlinesByWeek[docSnap.id] = new Date(data.deadline);
    }
  });

  const now = new Date();
  let closestWeek = null, minDiff = Infinity;
  for (let week of weeks) {
    const deadline = deadlinesByWeek[week];
    if (deadline) {
      const diff = Math.abs(deadline - now);
      if (diff < minDiff) {
        minDiff = diff;
        closestWeek = week;
      }
    }
  }

if (!currentGameweek) {
  currentGameweek = closestWeek || weeks[0] || "1";
}
  const gameweekSelect = document.getElementById("gameweekSelect");
  gameweekSelect.innerHTML = weeks.map(w => `<option value="${w}">Gameweek ${w}</option>`).join("");
  gameweekSelect.value = currentGameweek;
  subscribeToGameweek(currentGameweek);
}

document.getElementById("gameweekSelect").onchange = async (e) => {
  currentGameweek = e.target.value;
  localStorage.setItem("selectedGameweek", currentGameweek);
  unsubscribeAll();
  subscribeToGameweek(currentGameweek);
};

let unsubscribeFns = [];

function unsubscribeAll() {
  unsubscribeFns.forEach(fn => fn());
  unsubscribeFns = [];
}

function subscribeToGameweek(gameweek) {
  unsubscribeAll(); // Remove previous listeners

  // 🔄 Fixtures (real-time)
  const qFixtures = query(collection(db, "fixtures"), where("gameweek", "==", gameweek));
  const unsubFixtures = onSnapshot(qFixtures, snapshot => {
    const fixtures = snapshot.docs.map(d => ({ id: d.id, ...d.data() }));
    currentFixtures = fixtures;
    if (!gameweekCache[gameweek]) gameweekCache[gameweek] = {};
    gameweekCache[gameweek].fixtures = fixtures;
    sessionStorage.setItem("gameweekCache", JSON.stringify(gameweekCache));
    renderGameweek();
  });
  unsubscribeFns.push(unsubFixtures);

  // 🔄 Predictions
  const unsubPred = onSnapshot(doc(db, "predictions", gameweek), snap => {
    const data = snap.exists() ? snap.data() : {};
    currentPredictions = data;
    if (!gameweekCache[gameweek]) gameweekCache[gameweek] = {};
    gameweekCache[gameweek].predictions = data;
    sessionStorage.setItem("gameweekCache", JSON.stringify(gameweekCache));
    renderGameweek();
  });
  unsubscribeFns.push(unsubPred);

  // 🔄 Results
  const unsubRes = onSnapshot(doc(db, "results", gameweek), snap => {
    const data = snap.exists() ? snap.data() : {};
    currentResults = data;
    if (!gameweekCache[gameweek]) gameweekCache[gameweek] = {};
    gameweekCache[gameweek].results = data;
    sessionStorage.setItem("gameweekCache", JSON.stringify(gameweekCache));
    renderGameweek();
    renderLeaderboardsFromLocalCache();
  });
  unsubscribeFns.push(unsubRes);

  // 🔄 Deadline
  const unsubDeadline = onSnapshot(doc(db, "deadlines", gameweek), snap => {
    if (snap.exists()) {
      const deadline = snap.data().deadline;
      deadlinesByWeek[gameweek] = new Date(deadline);
      if (!gameweekCache[gameweek]) gameweekCache[gameweek] = {};
      gameweekCache[gameweek].deadline = deadline;
      sessionStorage.setItem("gameweekCache", JSON.stringify(gameweekCache));
      sessionStorage.setItem("deadlinesByWeek", JSON.stringify(deadlinesByWeek));
      document.getElementById("gameweekDeadline").textContent =
        `Deadline: ${new Date(deadline).toLocaleString()}`;
    }
  });
  unsubscribeFns.push(unsubDeadline);
}

function renderGameweek() {
  if (!Array.isArray(currentFixtures)) currentFixtures = [];
if (!currentPredictions || typeof currentPredictions !== "object") currentPredictions = {};
if (!currentResults || typeof currentResults !== "object") currentResults = {};
const fixturesContainer = document.getElementById("fixturesContainer");
  fixturesContainer.innerHTML = "";

 const rawDeadline = deadlinesByWeek[currentGameweek];
const deadline = rawDeadline instanceof Date ? rawDeadline : new Date(rawDeadline);
const afterDeadline = deadline && new Date() > deadline;

  for (const fixture of currentFixtures) {
    const result = currentResults[fixture.id];
    const pred = currentPredictions[fixture.id]?.[currentUser];
    const isLocked = !!result || afterDeadline;
    const hasPrediction = !!pred;

    const div = document.createElement("div");
    div.className = "border p-3 my-2 bg-white rounded shadow";

div.innerHTML = `
  <div class="flex flex-col md:flex-row md:justify-between md:items-center gap-2">
    <div class="font-semibold flex flex-wrap items-center">
      <span class="homeTeam flex items-center mr-2">
        <img src="${getLogoUrl(fixture.home)}" alt="${fixture.home}" class="w-5 h-5 mr-1 inline" />
        ${fixture.home}
      </span>
      <span class="mx-1">vs</span>
      <span class="awayTeam flex items-center ml-2">
        <img src="${getLogoUrl(fixture.away)}" alt="${fixture.away}" class="w-5 h-5 mr-1 inline" />
        ${fixture.away}
      </span>
      <button class="historyBtn bg-yellow-100 hover:bg-yellow-200 px-2 py-1 rounded text-xs ml-2 mt-2 md:mt-0">
        Fixture Data
      </button>
    </div>
    ${currentUser === "david" ? `
      <div class="flex gap-2 flex-wrap">
        <button class="editBtn bg-blue-100 hover:bg-blue-200 px-2 py-1 rounded text-sm">Edit</button>
        <button class="deleteFixtureBtn bg-red-100 hover:bg-red-200 px-2 py-1 rounded text-sm">Delete</button>
      </div>` : ""}
  </div>

  <div class="mt-3 flex flex-col md:flex-row gap-4">
    <div>
      <label class="text-sm block mb-1">Your Prediction:</label>
      ${
        isLocked && pred
          ? `<div class="inline-block bg-blue-100 border px-3 py-1 rounded">${pred.home} : ${pred.away}</div>`
          : pred
            ? `<div class="flex flex-wrap items-center gap-2">
                <input type="number" min="0" class="border p-2 w-16 predHome" value="${pred?.home ?? ""}">
                <span>:</span>
                <input type="number" min="0" class="border p-2 w-16 predAway" value="${pred?.away ?? ""}">
                <button class="savePred bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded text-sm">Save</button>
                <button class="deletePred bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded text-sm">Delete</button>
              </div>`
            : isLocked
              ? `<div class="text-red-500 italic">Not submitted</div>`
              : `<div class="flex flex-wrap items-center gap-2">
                  <input type="number" min="0" class="border p-2 w-16 predHome" value="">
                  <span>:</span>
                  <input type="number" min="0" class="border p-2 w-16 predAway" value="">
                  <button class="savePred bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded text-sm">Save</button>
                </div>`
      }
    </div>

    <div>
${
  currentUser === "david"
    ? `<label class="text-sm block mb-1">Result:</label>
       <div class="flex flex-wrap items-center gap-2">
         <input type="number" min="0" class="border p-2 w-16 resHome" value="${result?.home ?? ""}">
         <span>:</span>
         <input type="number" min="0" class="border p-2 w-16 resAway" value="${result?.away ?? ""}">
         <button class="saveRes bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded text-sm">Save</button>
         ${result ? `<button class="deleteRes bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded text-sm">Delete</button>` : ""}
       </div>`
    : result
      ? `<label class="text-sm block mb-1">Result:</label>
         <div class="bg-gray-200 border px-3 py-1 rounded inline-block">${result.home} : ${result.away}</div>`
      : ""
}
    </div>
  </div>

  <div class="text-sm mt-3 playersPredictions"></div>
`;

    fixturesContainer.appendChild(div);

    // Event listeners (unchanged)
    div.querySelector(".savePred")?.addEventListener("click", async () => {
      const h = div.querySelector(".predHome").value;
      const a = div.querySelector(".predAway").value;
      const snap = await getDoc(doc(db, "predictions", currentGameweek));
      const data = snap.exists() ? snap.data() : {};
      if (!data[fixture.id]) data[fixture.id] = {};
      data[fixture.id][currentUser] = { home: +h, away: +a };
await updateDoc(doc(db, "predictions", currentGameweek), {
  [`${fixture.id}.${currentUser}`]: { home: +h, away: +a }
});

      currentPredictions[fixture.id] = { ...currentPredictions[fixture.id], [currentUser]: { home: +h, away: +a } };
      gameweekCache[currentGameweek].predictions = currentPredictions;
      sessionStorage.setItem("gameweekCache", JSON.stringify(gameweekCache));

      renderGameweek();
    });

    div.querySelector(".deletePred")?.addEventListener("click", async () => {
      const snap = await getDoc(doc(db, "predictions", currentGameweek));
      if (!snap.exists()) return;
      const data = snap.data();
      delete data[fixture.id][currentUser];
      if (Object.keys(data[fixture.id]).length === 0) delete data[fixture.id];
await updateDoc(doc(db, "predictions", currentGameweek), {
  [`${fixture.id}.${currentUser}`]: deleteField()
});

      if (currentPredictions[fixture.id]) {
        delete currentPredictions[fixture.id][currentUser];
      }
      gameweekCache[currentGameweek].predictions = currentPredictions;
      sessionStorage.setItem("gameweekCache", JSON.stringify(gameweekCache));
      renderGameweek();
    });

    div.querySelector(".saveRes")?.addEventListener("click", async () => {
      const h = div.querySelector(".resHome").value;
      const a = div.querySelector(".resAway").value;
      const snap = await getDoc(doc(db, "results", currentGameweek));
      const data = snap.exists() ? snap.data() : {};
      data[fixture.id] = { home: +h, away: +a };
await updateDoc(doc(db, "results", currentGameweek), {
  [`${fixture.id}`]: { home: +h, away: +a }
});

      currentResults[fixture.id] = { home: +h, away: +a };
      gameweekCache[currentGameweek].results = currentResults;
      sessionStorage.setItem("gameweekCache", JSON.stringify(gameweekCache));

      renderGameweek();
renderLeaderboardsFromLocalCache();
    });

    div.querySelector(".deleteRes")?.addEventListener("click", async () => {
      if (!confirm("Are you sure you want to delete this result?")) return;
      const snap = await getDoc(doc(db, "results", currentGameweek));
      if (!snap.exists()) return;
      const data = snap.data();
      delete data[fixture.id];
await updateDoc(doc(db, "results", currentGameweek), {
  [`${fixture.id}`]: deleteField()
});
      delete currentResults[fixture.id];
gameweekCache[currentGameweek].results = currentResults;
sessionStorage.setItem("gameweekCache", JSON.stringify(gameweekCache));

      renderGameweek();
renderLeaderboardsFromLocalCache();
    });

div.querySelector(".editBtn")?.addEventListener("click", async () => {
  const newHome = prompt("New home team name:", fixture.home)?.trim();
  const newAway = prompt("New away team name:", fixture.away)?.trim();

  if (!newHome || !newAway) return;

  await setDoc(doc(db, "fixtures", fixture.id), {
    home: newHome,
    away: newAway,
    gameweek: currentGameweek // ✅ required for real-time updates to work
  });

  fixture.home = newHome;
  fixture.away = newAway;

  renderGameweek(); // ✅ Update local UI immediately
});

div.querySelector(".deleteFixtureBtn")?.addEventListener("click", async () => {
  if (!confirm("Are you sure you want to delete this fixture?")) return;

  await deleteDoc(doc(db, "fixtures", fixture.id));

  // Update local cache and UI
  currentFixtures = currentFixtures.filter(f => f.id !== fixture.id);
  gameweekCache[currentGameweek].fixtures = currentFixtures;
  sessionStorage.setItem("gameweekCache", JSON.stringify(gameweekCache));

  renderGameweek();
});

    // Show predictions from others ONLY if this user submitted one or the fixture is not locked
    const predDiv = div.querySelector(".playersPredictions");
    const all = currentPredictions[fixture.id] || {};

    const showOthers = hasPrediction;

  if (showOthers && Object.keys(all).length > 0) {
      let html = `
        <div class="mt-3 border border-gray-300 rounded overflow-hidden">
          <table class="table-auto w-full text-sm">
            <thead class="bg-gray-100 text-left">
              <tr>
                <th class="px-2 py-1">Player</th>
                <th class="px-2 py-1">Prediction</th>
                <th class="px-2 py-1">Points</th>
              </tr>
            </thead>
            <tbody>
      `;
      for (let player in all) {
        const p = all[player];
        const res = currentResults[fixture.id];
        let pts = res ? calculatePoints(p, res) : "-";

        let predictionDisplay = "🔒";
if (res || player === currentUser || afterDeadline) {
  predictionDisplay = `${p.home}:${p.away}`;
}

let predictionClass = (!res && player !== currentUser && !afterDeadline)
  ? 'text-gray-400 italic'
  : '';

let tooltip = (!res && player !== currentUser && !afterDeadline)
  ? 'title="Hidden until result is submitted or deadline passed"'
  : '';

        let ptsBgClass = "bg-gray-400";
        if (typeof pts === "number") {
          if (pts === 5) ptsBgClass = "bg-green-600";
          else if (pts >= 2) ptsBgClass = "bg-yellow-500";
          else ptsBgClass = "bg-red-500";
        }

        html += `
          <tr class="hover:bg-gray-50">
            <td class="border-t px-2 py-1">${player.charAt(0).toUpperCase() + player.slice(1)}</td>
            <td class="border-t px-2 py-1">
              <span class="${predictionClass}" ${tooltip}>${predictionDisplay}</span>
            </td>
            <td class="border-t px-2 py-1">
              <span class="px-2 py-1 rounded-full text-white text-xs ${ptsBgClass}">${pts}</span>
            </td>
          </tr>`;
      }
      html += `</tbody></table></div>`;
      predDiv.innerHTML = html;
    } else {
      predDiv.innerHTML = "";
    }
  }

// Rebuild merged predictions/results/fixtures from all cached gameweeks
const allPredictions = {};
const allResults = {};
const allFixtures = [];

for (const entry of Object.values(gameweekCache || {})) {
  // Some weeks may not be fully populated yet — guard every read
  const fixtures    = Array.isArray(entry?.fixtures) ? entry.fixtures : [];
  const predictions = (entry?.predictions && typeof entry.predictions === "object") ? entry.predictions : {};
  const results     = (entry?.results && typeof entry.results === "object") ? entry.results : {};

  for (const f of fixtures) allFixtures.push(f);

  for (const [fid, preds] of Object.entries(predictions)) {
    allPredictions[fid] = { ...(allPredictions[fid] || {}), ...(preds || {}) };
  }
  for (const [fid, res] of Object.entries(results)) {
    allResults[fid] = res;
  }
}
}

function calculatePoints(pred, res) {
  let pts = 0;
  if (pred.home === res.home) pts++;
  if (pred.away === res.away) pts++;
  if (Math.sign(pred.home - pred.away) === Math.sign(res.home - res.away)) pts += 2;
  if (pred.home === res.home && pred.away === res.away) pts++;
  return pts;
}

// ——— Helpers ———
let _seasonStatsCache = null;

async function getSeasonStats() {
  if (_seasonStatsCache) return _seasonStatsCache;
  const s = await getDoc(doc(db, "stats", "season"));
  if (!s.exists()) throw new Error("stats/season not found. Have David pressed 'Compute & Save Season Stats'?");
  _seasonStatsCache = s.data();
  return _seasonStatsCache;
}

function renderFormLetters(arr) {
  return (arr || []).map(r => {
    if (r === "W") return `<span class="text-green-600 font-bold">W</span>`;
    if (r === "L") return `<span class="text-red-600 font-bold">L</span>`;
    return `<span class="text-gray-600 font-bold">D</span>`;
  }).join(" ");
}

function formPoints(arr) {
  return (arr || []).reduce((sum, r) => sum + (r === "W" ? 3 : r === "D" ? 1 : 0), 0);
}

function matchOutcomeFromScore(h, a) {
  if (h > a) return "H";
  if (h < a) return "A";
  return "D";
}
function pointsForOutcome(outcome, asTeam) {
  // asTeam: 'home' or 'away'
  if (outcome === "H") return asTeam === "home" ? 3 : 0;
  if (outcome === "A") return asTeam === "away" ? 3 : 0;
  return 1; // draw
}
function teamStatsAccumulator() {
  return { played:0, wins:0, draws:0, losses:0, gf:0, ga:0, gd:0, points:0, forms:[] };
}
function normalizeNameLeague(name) {
  // keep exactly your display names; tweak mappings if needed
  return name;
}

// Extract numeric timestamp from fixture id "..._<ts>"
function fixtureTimeFromId(fixtureId) {
  const tail = fixtureId.split("_").pop();
  const n = Number(tail);
  return Number.isFinite(n) ? n : 0;
}

// ——— Compute all stats up to currentGameweek ———
async function computeSeasonStatsUpToCurrentGW() {
  // Ensure cache has all weeks ≤ currentGW
  const fixtureDocs = await getDocs(collection(db, "fixtures"));
  const allFixtures = fixtureDocs.docs.map(d => ({ id: d.id, ...d.data() }));
  const allWeeks = [...new Set(allFixtures.map(f => String(f.gameweek)))].filter(Boolean);

  for (const w of allWeeks) {
    if (+w > +currentGameweek) continue;
    if (!gameweekCache[w] || !gameweekCache[w].fixtures) {
      const fixtures = allFixtures.filter(f => String(f.gameweek) === w);
      const [predSnap, resSnap] = await Promise.all([
        getDoc(doc(db, "predictions", w)),
        getDoc(doc(db, "results", w))
      ]);
      gameweekCache[w] = gameweekCache[w] || {};
      gameweekCache[w].fixtures    = fixtures;
      gameweekCache[w].predictions = predSnap.exists() ? predSnap.data() : {};
      gameweekCache[w].results     = resSnap.exists() ? resSnap.data() : {};
    }
  }

  // Real table + helper maps
  const teamTable = {};         // team -> aggregates (from results only)
  const teamMatchesChrono = {}; // team -> ['W','D','L',...]
  const teamRealPoints = {};    // team -> real points

  // Predicted points per team (two flavors)
  // CHANGED: values are now objects { pts, gf, ga } for ALL predictions
  const playerTeamPredAll    = {}; // user -> team -> { pts,gf,ga }
  const playerTeamPredScored = {}; // user -> team -> pts (ONLY fixtures WITH results)

  const sortedWeeks = Object.keys(gameweekCache)
    .map(String).filter(w => +w <= +currentGameweek)
    .sort((a,b)=>+a - +b);

  for (const w of sortedWeeks) {
    const { fixtures = [], results = {}, predictions = {} } = gameweekCache[w] || {};
    const fixturesSorted = [...fixtures].sort((a,b) => fixtureTimeFromId(a.id) - fixtureTimeFromId(b.id));

    for (const f of fixturesSorted) {
      const fid = f.id;
      const res = results[fid];
      const home = normalizeNameLeague(f.home);
      const away = normalizeNameLeague(f.away);

      // ----- REAL table (only when result exists)
      if (res && Number.isFinite(res.home) && Number.isFinite(res.away)) {
        const out = matchOutcomeFromScore(res.home, res.away);

        teamTable[home] = teamTable[home] || teamStatsAccumulator();
        teamTable[away] = teamTable[away] || teamStatsAccumulator();
        teamMatchesChrono[home] = teamMatchesChrono[home] || [];
        teamMatchesChrono[away] = teamMatchesChrono[away] || [];
        teamRealPoints[home] = teamRealPoints[home] || 0;
        teamRealPoints[away] = teamRealPoints[away] || 0;

        const th = teamTable[home], ta = teamTable[away];
        const homePts = pointsForOutcome(out, "home");
        const awayPts = pointsForOutcome(out, "away");

        th.played++; ta.played++;
        th.gf += res.home; th.ga += res.away;
        ta.gf += res.away; ta.ga += res.home;
        th.gd = th.gf - th.ga; ta.gd = ta.gf - ta.ga;
        if (out === "H") { th.wins++; ta.losses++; }
        else if (out === "A") { ta.wins++; th.losses++; }
        else { th.draws++; ta.draws++; }
        th.points += homePts; ta.points += awayPts;
        teamRealPoints[home] += homePts; teamRealPoints[away] += awayPts;

        teamMatchesChrono[home].push(out === "H" ? "W" : (out === "A" ? "L" : "D"));
        teamMatchesChrono[away].push(out === "A" ? "W" : (out === "H" ? "L" : "D"));
      }

      // ----- PREDICTED points (always add to ALL; add to SCORED only if result exists)
      const predsForFixture = predictions[fid] || {};
      for (const [user, p] of Object.entries(predsForFixture)) {
        if (!p || !Number.isFinite(p.home) || !Number.isFinite(p.away)) continue;
        const predictedOutcome = matchOutcomeFromScore(p.home, p.away);
        const homePredPts = pointsForOutcome(predictedOutcome, "home");
        const awayPredPts = pointsForOutcome(predictedOutcome, "away");

        // === MINIMAL CHANGE START: accumulate {pts,gf,ga} for ALL predictions
        (playerTeamPredAll[user] ||= {});
        const aggH = (playerTeamPredAll[user][home] ||= { pts: 0, gf: 0, ga: 0 });
        const aggA = (playerTeamPredAll[user][away] ||= { pts: 0, gf: 0, ga: 0 });

        aggH.pts += homePredPts;  aggA.pts += awayPredPts;
        aggH.gf  += p.home;       aggA.gf  += p.away;
        aggH.ga  += p.away;       aggA.ga  += p.home;
        // === MINIMAL CHANGE END

        if (res && Number.isFinite(res.home) && Number.isFinite(res.away)) {
          (playerTeamPredScored[user] ||= {});
          playerTeamPredScored[user][home] = (playerTeamPredScored[user][home] || 0) + homePredPts;
          playerTeamPredScored[user][away] = (playerTeamPredScored[user][away] || 0) + awayPredPts;
        }
      }
    }
  }

  // Build league table positions from results
  const teams = Object.keys(teamTable);
  const tableArr = teams.map(team => ({
    team, ...teamTable[team],
  })).sort((a,b) => b.points - a.points || b.gd - a.gd || b.gf - a.gf || a.team.localeCompare(b.team));

  const positionByTeam = {};
  tableArr.forEach((row, i) => positionByTeam[row.team] = i + 1);

  const teamsDoc = {};
  for (const team of teams) {
    const t = teamTable[team];
    const last6 = (teamMatchesChrono[team] || []).slice(-6);
    teamsDoc[team] = {
      form: last6, position: positionByTeam[team] || null,
      played: t.played, wins: t.wins, draws: t.draws, losses: t.losses,
      gf: t.gf, ga: t.ga, gd: t.gd, points: t.points
    };
  }

  return {
    currentGameweek: String(currentGameweek),
    teams: teamsDoc,
    teamRealPoints,
    playerPredictedTeamPointsAll:    playerTeamPredAll,    // NOW: { pts,gf,ga }
    playerPredictedTeamPointsScored: playerTeamPredScored, // unchanged (number pts)
  };
}

async function openLeagueTableModal() {
  const stats = await getSeasonStats();
  const teams = stats.teams || {};
  const gw = stats.currentGameweek ?? currentGameweek;

  // Build array and sort by position ASC
  const rows = Object.entries(teams).map(([team, t]) => ({
    team,
    pos: t.position ?? 9999,
    W: t.wins ?? 0,
    D: t.draws ?? 0,
    L: t.losses ?? 0,
    Pts: t.points ?? 0,
    GF: t.gf ?? 0,
    GA: t.ga ?? 0,
    GD: (t.gd ?? ((t.gf ?? 0) - (t.ga ?? 0)))
  })).sort((a,b)=> a.pos - b.pos || a.team.localeCompare(b.team));

  const thead = `
    <thead class="bg-gray-100">
      <tr>
        <th class="px-2 py-1 text-left">Pos</th>
        <th class="px-2 py-1 text-left">Team</th>
        <th class="px-2 py-1 text-right">W</th>
        <th class="px-2 py-1 text-right">D</th>
        <th class="px-2 py-1 text-right">L</th>
        <th class="px-2 py-1 text-right">Pts</th>
        <th class="px-2 py-1 text-right">GF</th>
        <th class="px-2 py-1 text-right">GA</th>
        <th class="px-2 py-1 text-right">GD</th>
      </tr>
    </thead>`;

  const tbody = rows.map(r => `
    <tr class="hover:bg-gray-50">
      <td class="px-2 py-1"><span class="text-red-600 font-bold">${r.pos}.</span></td>
      <td class="px-2 py-1">${r.team}</td>
      <td class="px-2 py-1 text-right">${r.W}</td>
      <td class="px-2 py-1 text-right">${r.D}</td>
      <td class="px-2 py-1 text-right">${r.L}</td>
      <td class="px-2 py-1 text-right font-semibold">${r.Pts}</td>
      <td class="px-2 py-1 text-right">${r.GF}</td>
      <td class="px-2 py-1 text-right">${r.GA}</td>
      <td class="px-2 py-1 text-right">${r.GD}</td>
    </tr>
  `).join("");

  document.getElementById("statsModalTitle").textContent =
    `League Table`;

  document.getElementById("statsModalContent").innerHTML = `
    <div class="overflow-x-auto">
      <table class="table-auto w-full border text-sm">
        ${thead}
        <tbody>${tbody}</tbody>
      </table>
    </div>
  `;

  document.getElementById("statsModal").classList.remove("hidden");
}

async function openFormGuideModal() {
  const stats = await getSeasonStats();
  const teams = stats.teams || {};
  const gw = stats.currentGameweek ?? currentGameweek;

  // sort by form points (last-6), then GD, then GF, then team
  const rows = Object.entries(teams).map(([team, t]) => {
    const form = t.form || [];
    const last6 = form.slice(-6);
    return {
      team,
      pos: t.position ?? 9999,
      last6,
      last6Pts: formPoints(last6),
      gd: t.gd ?? ((t.gf ?? 0)-(t.ga ?? 0)),
      gf: t.gf ?? 0
    };
  }).sort((a,b) =>
    b.last6Pts - a.last6Pts ||
    b.gd - a.gd ||
    b.gf - a.gf ||
    a.team.localeCompare(b.team)
  );

  const list = rows.map(r => `
    <div class="flex items-center justify-between py-1 border-b">
      <div class="flex items-center gap-2">
        <span class="text-red-600 font-bold">${r.pos}.</span>
        <span class="font-medium">${r.team}</span>
      </div>
      <div class="flex items-center gap-3">
        <span class="whitespace-nowrap">${renderFormLetters(r.last6)}</span>
        <span class="text-xs text-gray-600">(${r.last6Pts} pts)</span>
      </div>
    </div>
  `).join("");

  document.getElementById("statsModalTitle").textContent =
    `Form Guide (last 6)`;

  document.getElementById("statsModalContent").innerHTML = `
    <div class="text-sm">
      ${list}
    </div>
  `;

  document.getElementById("statsModal").classList.remove("hidden");
}

function pickTeamsByValue(map, selectorFn) {
  // Returns { value, teams[] } for the chosen selector over the map's values
  const entries = Object.entries(map);
  if (entries.length === 0) return { value: null, teams: [] };
  let bestVal = null;
  let teams = [];
  for (const [team, val] of entries) {
    const v = selectorFn(val);
    if (bestVal === null || v > bestVal) { bestVal = v; teams = [team]; }
    else if (v === bestVal) teams.push(team);
  }
  return { value: bestVal, teams };
}

function pickTeamsByMinAbsDiff(diffMap) {
  // diffMap: team -> absDiff
  const entries = Object.entries(diffMap);
  if (entries.length === 0) return { value: null, teams: [] };
  let best = null, teams = [];
  for (const [team, v] of entries) {
    if (best === null || v < best) { best = v; teams = [team]; }
    else if (v === best) teams.push(team);
  }
  return { value: best, teams };
}

function htmlTeamsList(teams, suffix = "") {
  if (!teams || teams.length === 0) return "–";
 return teams.map(t => `<span class="font-medium">${t}</span>`).join(", ");
}

async function openPredictionStatsModal() {
  const stats = await getSeasonStats();
  const gw = stats.currentGameweek ?? currentGameweek;

  // Real points by team (only from fixtures with results)
  const teamRealPoints = (stats.teamRealPoints && Object.keys(stats.teamRealPoints).length)
    ? stats.teamRealPoints
    : Object.fromEntries(
        Object.entries(stats.teams || {}).map(([team, t]) => [team, t.points ?? 0])
      );

  // Predictions saved in Firestore by your compute/save step
  const perPlayerAll    = stats.playerPredictedTeamPointsAll    || {}; // NOW: { team: {pts,gf,ga} }
  const perPlayerScored = stats.playerPredictedTeamPointsScored || {}; // { team: pts }

  const realTeams = new Set(Object.keys(teamRealPoints));
  const realTeamsArray = Array.from(realTeams);

  let html = "";

  // Iterate every player that appears in either map
  const players = Array.from(new Set([
    ...Object.keys(perPlayerAll),
    ...Object.keys(perPlayerScored)
  ])).sort();

  for (const player of players) {
    const tAllRaw = perPlayerAll[player]    || {}; // team -> {pts,gf,ga} OR legacy number
    const tScored = perPlayerScored[player] || {}; // team -> pts

    // --- Map ALL to pure points for liked/hated (backward compatible) ---
    const predictedAllPts = Object.fromEntries(
      Object.entries(tAllRaw).map(([team, v]) => [
        team,
        (typeof v === "number") ? v : Number(v?.pts ?? 0)
      ])
    );

    // ----- Most liked / Most hated (use ALL predictions, by pts) -----
    const mostLiked = pickTeamsByValue(predictedAllPts, v => v);
    const mostHated = (() => {
      const entries = Object.entries(predictedAllPts);
      if (entries.length === 0) return { value: null, teams: [] };
      let bestVal = null, teams = [];
      for (const [team, v] of entries) {
        const inv = -v;
        if (bestVal === null || inv > bestVal) { bestVal = inv; teams = [team]; }
        else if (inv === bestVal) teams.push(team);
      }
      return { value: -bestVal, teams };
    })();

    // ----- Over/Under/Best predicted (ONLY scored predictions vs real) -----
    const predictedScored = {};
    for (const team of realTeamsArray) {
      predictedScored[team] = tScored[team] ?? 0;
    }

    const delta = {};   // predicted - real
    const absDiff = {}; // |real - predicted|
    for (const team of realTeamsArray) {
      const p = predictedScored[team] ?? 0;
      const r = teamRealPoints[team] ?? 0;
      delta[team]   = p - r;
      absDiff[team] = Math.abs(r - p);
    }

    const mostOver  = pickTeamsByValue(delta, v => v);
    const mostUnder = (() => {
      const entries = Object.entries(delta);
      if (entries.length === 0) return { value: null, teams: [] };
      let bestVal = null, teams = [];
      for (const [team, v] of entries) {
        const inv = -v;
        if (bestVal === null || inv > bestVal) { bestVal = inv; teams = [team]; }
        else if (inv === bestVal) teams.push(team);
      }
      return { value: bestVal, teams }; // value is (real - predicted)
    })();

    const bestPred = pickTeamsByMinAbsDiff(absDiff);

    // ===== NEW: Predicted table (ALL predictions -> pts,gf,ga) =====
    // Build rows from tAllRaw, supporting both new object shape and old numeric fallback.
    const tableRows = Object.entries(tAllRaw).map(([team, v]) => {
      const pts = (typeof v === "number") ? v : Number(v?.pts ?? 0);
      const gf  = (typeof v === "number") ? 0 : Number(v?.gf  ?? 0);
      const ga  = (typeof v === "number") ? 0 : Number(v?.ga  ?? 0);
      return { team, pts, gd: gf - ga, gf };
    });

    tableRows.sort((a, b) =>
      b.pts - a.pts ||
      b.gd  - a.gd  ||
      b.gf  - a.gf  ||
      a.team.localeCompare(b.team)
    );

    const tableHtml = tableRows.length ? `
      <table class="w-full text-sm mt-2 border border-gray-200 rounded overflow-hidden">
        <thead>
          <tr class="bg-gray-50">
            <th class="w-10 text-right px-2 py-1">#</th>
            <th class="text-left px-2 py-1">Team</th>
            <th class="w-14 text-right px-2 py-1">Pts</th>
          </tr>
        </thead>
        <tbody>
          ${tableRows.map((r, i) => `
            <tr class="${i % 2 ? 'bg-white' : 'bg-gray-50'}">
              <td class="text-right px-2 py-1">${i + 1}</td>
              <td class="px-2 py-1 truncate">${r.team}</td>
              <td class="text-right px-2 py-1">${r.pts}</td>
            </tr>
          `).join("")}
        </tbody>
      </table>
    ` : `<div class="text-sm text-gray-500 mt-2">No predicted table data.</div>`;

    // ----- Assemble per-player section -----
    html += `
      <div class="mb-6 border-b pb-4">
        <div class="text-base font-semibold mb-2">${player.charAt(0).toUpperCase() + player.slice(1)}</div>
        <div class="text-sm space-y-1">
          <div>
            <span class="font-medium">Most liked team:</span>
            ${htmlTeamsList(mostLiked.teams)}
            <span class="text-gray-600">(${mostLiked.value ?? 0} pts)</span>
          </div>
          <div>
            <span class="font-medium">Most hated team:</span>
            ${htmlTeamsList(mostHated.teams)}
            <span class="text-gray-600">(${mostHated.value ?? 0} pts)</span>
          </div>
          <div>
            <span class="font-medium">Most overrated team:</span>
            ${htmlTeamsList(mostOver.teams)}
            <span class="text-gray-600">(+${mostOver.value ?? 0})</span>
          </div>
          <div>
            <span class="font-medium">Most underrated team:</span>
            ${htmlTeamsList(mostUnder.teams)}
            <span class="text-gray-600">(-${mostUnder.value ?? 0})</span>
          </div>
          <div>
            <span class="font-medium">Best predicted team:</span>
            ${htmlTeamsList(bestPred.teams)}
            <span class="text-gray-600">(±${bestPred.value ?? 0})</span>
          </div>
        </div>

        <!-- Predicted table -->
        <div class="mt-3">
          <div class="text-sm font-medium mb-1">Predicted table (all predictions)</div>
          ${tableHtml}
        </div>
      </div>
    `;
  }

  document.getElementById("statsModalTitle").textContent = `Predictions stats`;
  document.getElementById("statsModalContent").innerHTML =
    html || "<div class='text-sm text-gray-600'>No data.</div>";
  document.getElementById("statsModal").classList.remove("hidden");
}
    
// Buttons + close
document.getElementById("btnLeagueTable")?.addEventListener("click", () => {
  openLeagueTableModal().catch(err => alert(err.message || String(err)));
});
document.getElementById("btnFormGuide")?.addEventListener("click", () => {
  openFormGuideModal().catch(err => alert(err.message || String(err)));
});
    document.getElementById("btnPredStats")?.addEventListener("click", () => {
  openPredictionStatsModal().catch(err => alert(err.message || String(err)));
});

document.getElementById("closeStatsBtn")?.addEventListener("click", () => {
  document.getElementById("statsModal").classList.add("hidden");
});

    
// ——— Persist to Firestore ———
async function saveSeasonStatsToFirestore() {
  const statusEl = document.getElementById("saveSeasonStatsStatus");
  try {
    statusEl.textContent = "Computing...";
    const payload = await computeSeasonStatsUpToCurrentGW();

    await setDoc(doc(db, "stats", "season"), {
      ...payload,
      updatedAt: new Date().toISOString()
    }, { merge: true });

    // clear local cache so next read pulls fresh doc
    _seasonStatsCache = null;

    statusEl.textContent = "✅ Saved season stats.";
    setTimeout(() => statusEl.textContent = "", 3000);
  } catch (e) {
    console.error(e);
    statusEl.textContent = "❌ Failed to save season stats. See console.";
    setTimeout(() => statusEl.textContent = "", 6000);
  }
}

    
function renderLeaderboards(allPredictions, allResults, allFixtures) {
  const overall = {}, exacts = {}, outcomes = {}, counts = {};
  const weekly = {}, wExacts = {}, wOutcomes = {}, wCounts = {};

  for (let fixture of allFixtures) {
    const fid = fixture.id;
    const res = allResults[fid];
    if (!res) continue;
    const preds = allPredictions[fid] || {};

    const isCurrentWeek = fixture.gameweek == currentGameweek;

    for (let user in preds) {
      const pts = calculatePoints(preds[user], res);
      const isExact = pts === 5;
      const isOutcome = pts >= 2;

      // Overall leaderboard
      overall[user] = (overall[user] || 0) + pts;
      counts[user] = (counts[user] || 0) + 1;
      if (isExact) exacts[user] = (exacts[user] || 0) + 1;
      if (isOutcome) outcomes[user] = (outcomes[user] || 0) + 1;

      // Weekly leaderboard (only current gameweek)
      if (isCurrentWeek) {
        weekly[user] = (weekly[user] || 0) + pts;
        wCounts[user] = (wCounts[user] || 0) + 1;
        if (isExact) wExacts[user] = (wExacts[user] || 0) + 1;
        if (isOutcome) wOutcomes[user] = (wOutcomes[user] || 0) + 1;
      }
    }
  }

  const render = (points, e = {}, o = {}, c = {}) =>
    `<table class="table-auto border w-full text-sm">
      <thead>
        <tr class="bg-gray-200">
          <th class="border px-2 py-1">Player</th>
          <th class="border px-2 py-1">Pts</th>
          <th class="border px-2 py-1">Exact (5)</th>
          <th class="border px-2 py-1">Outcome (2+)</th>
        </tr>
      </thead>
      <tbody>
        ${Object.entries(points).sort((a,b)=>b[1]-a[1]).map(([u,p]) => {
          const ex = e[u] || 0;
          const ou = o[u] || 0;
          const total = c[u] || 0;
          return `<tr class="text-center">
            <td class="border px-2 py-1">${u.charAt(0).toUpperCase() + u.slice(1)}</td>
            <td class="border px-2 py-1 font-semibold">${p}</td>
            <td class="border px-2 py-1">${ex} (${total ? Math.round(ex/total*100) : 0}%)</td>
            <td class="border px-2 py-1">${ou} (${total ? Math.round(ou/total*100) : 0}%)</td>
          </tr>`;
        }).join("")}
      </tbody>
    </table>`;

  document.getElementById("leaderboardOverall").innerHTML = render(overall, exacts, outcomes, counts);
  document.getElementById("leaderboardWeekly").innerHTML = render(weekly, wExacts, wOutcomes, wCounts);

  // ✅ Show overall leaderboard once it's accurate
document.getElementById("leaderboardOverall").classList.remove("hidden");
document.getElementById("leaderboardOverallLoading").classList.add("hidden");
}

function populatePasswordResetDropdown() {
  document.getElementById("resetUserSelect").innerHTML =
    Object.keys(users).map(u => `<option value="${u}">${u.charAt(0).toUpperCase() + u.slice(1)}</option>`).join("");
}

document.getElementById("resetPasswordBtn").onclick = async () => {
  const user = document.getElementById("resetUserSelect").value;
  const pass = document.getElementById("newPasswordInput").value.trim();
  if (!pass) return alert("Enter new password");
  await setDoc(doc(db, "passwords", user), { password: pass });
  alert("Password updated");
  document.getElementById("newPasswordInput").value = "";
};

document.getElementById("addFixtureBtn").onclick = async () => {
  const home = document.getElementById("newHomeTeam").value.trim();
  const away = document.getElementById("newAwayTeam").value.trim();
  if (!home || !away) return alert("Enter both teams");

  const id = `${currentGameweek}_${home}_${away}_${Date.now()}`;
  await setDoc(doc(db, "fixtures", id), {
    home,
    away,
    gameweek: currentGameweek // ✅ Required for onSnapshot to work
  });

  // Clear input fields
  document.getElementById("newHomeTeam").value = "";
  document.getElementById("newAwayTeam").value = "";

  // ✅ No need to re-subscribe — snapshot will pick up the change
  // Just clear cache and re-render locally
  delete gameweekCache[currentGameweek];

  renderGameweek(); // 👈 You may want this for instant UI feedback
};

document.getElementById("setDeadlineBtn").onclick = async () => {
  const deadline = document.getElementById("deadlineInput").value;
  if (!deadline) return;

  // ✅ Save to Firestore (this will trigger onSnapshot)
  await setDoc(doc(db, "deadlines", currentGameweek), { deadline });

  // ✅ Update local cache
  deadlinesByWeek[currentGameweek] = new Date(deadline);

  if (!gameweekCache[currentGameweek]) gameweekCache[currentGameweek] = {};
  gameweekCache[currentGameweek].deadline = deadline;

  // ✅ Save to sessionStorage
  sessionStorage.setItem("gameweekCache", JSON.stringify(gameweekCache));
  sessionStorage.setItem("deadlinesByWeek", JSON.stringify(deadlinesByWeek));

  // ❌ DON'T re-subscribe – live updates are automatic
  // ✅ Just update UI locally (optional)
  renderGameweek();
};

// Show history modal
const teamNameMap = {
  "Man Utd": "Manchester United",
  "Man City": "Manchester City",
  "Spurs": "Tottenham Hotspur",
  "Wolves": "Wolverhampton Wanderers",
  "Newcastle": "Newcastle United",
  "West Ham": "West Ham United",
  "Nott'm Forest": "Nottingham Forest",
  "Sheff Utd": "Sheffield United",
  "Leeds": "Leeds United",
  "Brighton": "Brighton & Hove Albion"
};

function normalizeTeam(name) {
  return teamNameMap[name] || name;
}

document.addEventListener("click", async (e) => {
  if (!e.target.classList.contains("historyBtn")) return;
  const card = e.target.closest(".border.p-3");
  const rawHome = card.querySelector(".homeTeam").textContent.trim();
  const rawAway = card.querySelector(".awayTeam").textContent.trim();
  const home = normalizeTeam(rawHome);
  const away = normalizeTeam(rawAway);
  const key = `${home} vs ${away}`;
  const snap = await getDoc(doc(db, "history", key));
  const modal = document.getElementById("historyModal");
  const content = document.getElementById("historyContent");

  if (!snap.exists()) {
    content.textContent = `No history found for ${home} vs ${away}`;
  } else {
    const data = snap.data();
    let html = `📊 Head-to-Head: ${home} vs ${away}\n\n`;

    // 🔹 Fetch season stats (league table + form)	
    let statsDoc;
    try {
      const statsSnap = await getDoc(doc(db, "stats", "season"));
      if (statsSnap.exists()) statsDoc = statsSnap.data();
    } catch (err) {
      console.error("Stats fetch failed", err);
    }

    const gwNumber = statsDoc?.currentGameweek ?? currentGameweek;
    
    if (statsDoc?.teams) {
      const tHome = statsDoc.teams[rawHome];
      const tAway = statsDoc.teams[rawAway];

      // Form guide renderer
      function renderForm(arr) {
        return (arr || []).map(r => {
          if (r === "W") return `<span class="text-green-600 font-bold">W</span>`;
          if (r === "L") return `<span class="text-red-600 font-bold">L</span>`;
          return `<span class="text-gray-600 font-bold">D</span>`;
        }).join(" ");
      }

      html += `Form Guide:\n- ${home}: ${renderForm(tHome?.form)}\n- ${away}: ${renderForm(tAway?.form)}\n\n`;


function renderPosition(pos) {
  if (!pos) return "-";
  return `<span class="text-red-600 font-bold">${pos}.</span>`;
}

html += `League Position:\n` +
        `- ${home}: ${renderPosition(tHome?.position)} (${tHome?.points ?? 0} pts)\n` +
        `- ${away}: ${renderPosition(tAway?.position)} (${tAway?.points ?? 0} pts)\n\n`;      
    }

   
    // Last 5 matches
    html += "Last 5 matches:\n";
    if (data.last5?.length) {
      data.last5.forEach(m => {
        const season = m.season || "–";
        html += `• ${m.home} ${m.gh}-${m.ga} ${m.away} (${season})\n`;
      });
    } else {
      html += "No recent matches found.\n";
    }

    // Summary
    const s = data.summary;
    const total = s.wins + s.draws + s.losses;
    html += `\nSummary:\n- Total matches: ${total}\n- ${home} Wins: ${s.wins}\n- Draws: ${s.draws}\n- ${away} Wins: ${s.losses}`;
    html += `\n- ${home} Goals: ${s.goalsFor}\n- ${away} Goals: ${s.goalsAgainst}`;

    // Biggest Wins
    html += `\n\nBiggest Wins:\n- ${home}: ${data.biggestWin?.[home] || "–"}\n- ${away}: ${data.biggestWin?.[away] || "–"}`;

    // Longest Streaks
    const hs = data.streaks?.[home];
    const as = data.streaks?.[away];
    html += `\n\nLongest Winning Streaks:\n- ${home}: ${hs?.count || 0} (${hs?.span || "–"})\n- ${away}: ${as?.count || 0} (${as?.span || "–"})`;

    content.innerHTML = html.replace(/\n/g, "<br>");
  }

  modal.classList.remove("hidden");
});

document.getElementById("closeHistoryBtn").onclick = () =>
  document.getElementById("historyModal").classList.add("hidden");

function renderLeaderboardsFromLocalCache() {
   const leaderboardEl = document.getElementById("leaderboardOverall");
  const loadingEl = document.getElementById("leaderboardOverallLoading");

  // Hide while rendering
  leaderboardEl.classList.add("hidden");
  loadingEl.classList.remove("hidden");
  const allPredictions = {};
  const allResults = {};
  const allFixtures = [];

  for (const week of Object.keys(gameweekCache)) {
    const { fixtures, predictions, results } = gameweekCache[week];

    for (const fixture of fixtures || []) {
      allFixtures.push(fixture);
      const fid = fixture.id;
      if (predictions?.[fid]) allPredictions[fid] = predictions[fid];
      if (results?.[fid]) allResults[fid] = results[fid];
    }
  }

  renderLeaderboards(allPredictions, allResults, allFixtures);
    leaderboardEl.classList.remove("hidden");
  loadingEl.classList.add("hidden");

}

// 🔁 Clear sessionStorage unless it's a full reload (Ctrl+Shift+R)
if (performance?.navigation?.type !== 1) {
  sessionStorage.clear();
}

document.getElementById("saveSeasonStatsBtn")?.addEventListener("click", () => {
  if (!confirm(`Compute & save season stats up to GW ${currentGameweek}?`)) return;
  saveSeasonStatsToFirestore();
});

    
window.addEventListener("DOMContentLoaded", async () => {
  const savedUser = localStorage.getItem("loggedInUser");
  const savedGameweek = localStorage.getItem("selectedGameweek");

  // Restore gameweekCache from sessionStorage if it exists
  const savedCache = sessionStorage.getItem("gameweekCache");
  const savedDeadlines = sessionStorage.getItem("deadlinesByWeek");

  if (savedCache) {
    try {
      gameweekCache = JSON.parse(savedCache);
    } catch (e) {
      console.error("Failed to parse cached gameweek data", e);
    }
  }

  if (savedDeadlines) {
    try {
      const raw = JSON.parse(savedDeadlines);
      // Convert string timestamps back to Date objects
      for (const [week, dateStr] of Object.entries(raw)) {
        deadlinesByWeek[week] = new Date(dateStr);
      }
    } catch (e) {
      console.error("Failed to parse cached deadlines", e);
    }
  }

  if (savedUser && users[savedUser]) {
    currentUser = savedUser;
    currentGameweek = savedGameweek || "1";

    loginSection.style.display = "none";
    appDiv.style.display = "block";
    welcomeUser.textContent = `Welcome, ${savedUser.charAt(0).toUpperCase() + savedUser.slice(1)}`;

    if (savedUser === "david") {
      document.getElementById("fixtureEditor").classList.remove("hidden");
      document.getElementById("passwordResetSection").classList.remove("hidden");
      populatePasswordResetDropdown();
    }

    document.getElementById("loadingOverlay").classList.remove("hidden");

    // If cache is empty, do full Firestore load
    if (Object.keys(gameweekCache).length === 0) {
      await loadAllGameweekDataForLeaderboards();
      await populateGameweekDropdown();
    } else {
      populateGameweekDropdownFromCache();
      renderLeaderboardsFromLocalCache();
    }

    subscribeToGameweek(currentGameweek);

    document.getElementById("loadingOverlay").classList.add("hidden");
  }
});

</script>
</body>
</html>
